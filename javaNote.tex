\documentclass[UTF8]{ctexart}
%\usepackage{CJKutf8}
\setCJKmainfont{KaiTi}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[%dvipdfm,  %pdflatex,pdftex这里决定运行文件的方式不同
pdfstartview=FitH,
CJKbookmarks=true,
bookmarksnumbered=true,
bookmarksopen=true,
colorlinks, %注释掉此项则交叉引用为彩色边框(将colorlinks和pdfborder同时注释掉)
pdfborder=001,   %注释掉此项则交叉引用为彩色边框
linkcolor=green,
anchorcolor=green,
citecolor=green
]{hyperref}  
\lstset{%  
alsolanguage=Java,  
%language={[ISO]C++},       %language为，还有{[Visual]C++}  
%alsolanguage=[ANSI]C,      %可以添加很多个alsolanguage,如alsolanguage=matlab,alsolanguage=VHDL等  
%alsolanguage= tcl,  
alsolanguage= XML,  
tabsize=4, %  
frame=shadowbox, %把代码用带有阴影的框圈起来  
commentstyle=\color{red!60!blue!90},%浅灰色的注释  
rulesepcolor=\color{red!20!green!20!blue!20},%代码块边框为淡青色  
keywordstyle=\color{blue!90}\bfseries, %代码关键字的颜色为蓝色，粗体  
showstringspaces=false,%不显示代码字符串中间的空格标记  
stringstyle=\ttfamily, % 代码字符串的特殊格式  
keepspaces=true, %  
breakindent=22pt, %  
numbers=left,%左侧显示行号 往左靠,还可以为right，或none，即不加行号  
stepnumber=1,%若设置为2，则显示行号为1,3,5，即stepnumber为公差,默认stepnumber=1  
%numberstyle=\tiny, %行号字体用小号  
numberstyle={\color[RGB]{0,192,192}\tiny} ,%设置行号的大小，大小有tiny,scriptsize,footnotesize,small,normalsize,large等  
numbersep=8pt,  %设置行号与代码的距离，默认是5pt  
basicstyle=\footnotesize, % 这句设置代码的大小  
showspaces=false, %  
flexiblecolumns=true, %  
breaklines=true, %对过长的代码自动换行  
breakautoindent=true,%  
breakindent=4em, %  
%escapebegin=\begin{CJK*}{GBK}{hei},escapeend=\end{CJK*},  
aboveskip=1em, %代码块边框  
tabsize=2,  
showstringspaces=false, %不显示字符串中的空格  
backgroundcolor=\color[RGB]{245,245,244},   %代码背景色  
%backgroundcolor=\color[rgb]{0.91,0.91,0.91}    %添加背景色  
escapeinside=``,  %在``里显示中文  
%% added by http://bbs.ctex.org/viewthread.php?tid=53451  
fontadjust,  
captionpos=t,  
framextopmargin=2pt,framexbottommargin=2pt,abovecaptionskip=-3pt,belowcaptionskip=3pt,  
xleftmargin=4em,xrightmargin=4em, % 设定listing左右的空白  
texcl=true,% 设定中文冲突，断行，列模式，数学环境输入，listing数字的样式  
%extendedchars=false,columns=flexible,mathescape=true  
%numbersep=-1em  
}  
\title{Java Note}
\author{徐国盛}
\begin{document}
%\begin{CJK}{UTF8}{gkai}
\maketitle
\tableofcontents
\section{Java基础}
\subsection{函数重载}
函数名一样，参数列表不一样，重载. 参数顺序不同也为重载。与函数的返回值没有任何关系
\begin{lstlisting}[language = Java]
void show (int a, char b, double c){}
a. void show(int x, char y, double z){} //because it is the same with original funciton
b. int show(int a, double c, char b){} //overload, Here are different parameter types
c. void show(int a, double c, char(b)){} //overload, it share the same reason as before
d. boolean show(int c, char b){}// overload =, because the number of parameters is different.
e. void show(double c){} //overload, the same reason as before.
f. double show(int x, char y, double z) //unoverload, it's denied in the same class
\end{lstlisting}
\subsection{数组}
\subsubsection{选择排序法和冒泡排序法}
在最后将交换位置的操作封装为一个功能。
%\input{../java/ArrayTest2.java}
\lstinputlisting[language = Java]{../java/ArrayTest2.java}

\subsubsection{数组的找key，折半查找}
折半查找一个key，前提是一个有序等的array。附加功能：对于一个有序数组，将一个元素查到该array中，并继续保证该array是有序的。
\lstinputlisting[language = Java]{../java/ArrayTest4.java}
%\end{CJK}
\subsubsection{进制转换}
在以下程序中，应用$>>>$时无符号右移，不是$>>$, 不然程序会有error。$>>$是有符号右移。在负数前面补1，正数前面补0。（这会导致成数组角标越界，因为多了一位，$--pos$会变为负数）
\lstinputlisting[language = Java]{../java/ArrayTest7.java}
\subsubsection{二维数组}
注意二维数组在内存中的存储
\lstinputlisting[language = Java]{../java/Array2Demo.java}
练习题
\lstinputlisting[language = Java]{../java/Array2Test.java}
\subsection{面向对象}

\subsubsection{成员变量和局部变量}
类类型变量指向对象

属性和行为构成了类成员。属性对应着类变量，行为对应这类中的函数。

1>作用范围

成员便来那个作用于整个类中，局部变量作用于函数中，或者语句中。

2>在内存中的位置

成员变量：在堆内存中，以为对象的存在，才在内存中存在。

局部变量：在栈内存中。

更改对象属性 对象.对象成员。


\subsubsection{匿名对象使用方式}

1>当对象的方法只调用一次时，可以用匿名对象完成，这样写比较简化。但如果对一个对象进行多个成员调用，必须给这个对象起个名字。

2>可以将匿名对象作为实际参数进行传递。但创建的对象不是垃圾。

\subsubsection{封装概述}
\textbf{封装}:对象的属性和实现细节，仅对外提供公共访问方式。
\textbf{封装原则}

\textbullet 将不需要对外提供的内容都隐藏起来。

\textbullet 把属性都隐藏，提供公共方法对其访问。
\lstinputlisting[language = Java]{../java/PersonDemo.java}
\subsubsection{构造函数}
\textbf{什么时候定义构造函数呢？}

当分析该事物时，该事物具备一些特性或者行为，那么将这些内容定义于构造函数中

\textbf{构造函数特点:}

\textbullet 函数名与类名相同

\textbullet 不定义返回值类型

\textbullet 不可以写return语句

\textbf{构造函数对象一建立就会调用与之对应的构造函数}

\textbf{构造函数的作用}：可以用于给对象进行初始化。若所有自定义构造函数被\textbf{private}关键字修饰，进行了私有化，那么对象将不能被创建。

\textbf{构造函数的小细节}：当一个类中没有定义构造函数时，那么系统会默认给该类加入一个空参数的构造函数。

当在类中自定义了构造函数后，系统就不再建立构造函数。
\lstinputlisting[language = Java]{../java/PersonDemo2.java}
\subsubsection{构造代码块}
\textbf{构造代码快作用}:给对象进行初始化。对象一建立就运行,而且优于构造函数运行。

\textbf{构造代码块与构造函数的区别}

\textbullet 构造代码块是给所有对象统一进行初始化。

\textbullet 构造函数是给对应对象进行初始化。

\textbf{将不同对象的共性初始化内容定义在构造代码块中}
\subsubsection{this关键字}
\textbf{this}关键字是用于区别局部变量和成员变量相同的情况。

\textbf{this}为什么能够解决局部变量与成员变量相同的问题？

\textbf{this}代表的是本类对象，到底代表哪一个。
\textbf{this}代表所在函数所属对象的引用。
简单说哪个对象在调用\textbf{this}所在的函数，\textbf{this}就代表哪个对象。

\textbf{this的应用}:当定义类中功能时，该函数内部要调用到该函数的对象时，这时运用\textbf{this}来表示这个对象。但凡本类功能内部使用到了本类对象，都用\textbf{this}。

\lstinputlisting[language = Java]{../java/PersonDemo3.java}

\textbf{this 与构造函数间的调用}

\textbf{this}语句：用于构造函数之间进行互相调用。

\textbf{this}语句只能定义在构造函数的第一行。因为初始化要先执行。
要注意防止死循环调用的发生。
\lstinputlisting[language = Java]{../java/PersonDemo4.java}
\subsubsection{static关键字}
\textbf{静态}：\textbf{static}
\textbf{用法}：是一个修饰符，用于修饰成员（成员变量，成员函数）。

当成源被静态修饰后，就多了一种调用方式，除了可以被对象调用外，还可以直接被
类名调用。格式是：\text{类名.静态成员}

\textbf{静态的特点}

1.随着类的加载而加载。也就是说，静态会随着类的消失而消失。说明它的生命周期最长。

2.优先于对象存在。明确一点：静态是优先存在的。对象是后存在的。

3.被所有的对象所共享。

4.可以直接被类名所调用。

\textbf{实例变量与类变量的区别}

1.存放位置
	
	类变量随着类的加载存在于方法区中。

	实例变量随着对象的建立而存在于堆内存中。

2.生命周期
	
	类变量声明周期最长，随着类的消失而消失。

	实例变量的生命周期，随着对象的消失而消失。

\textbf{静态的使用注意事项}

1.静态方法只能访问静态成员。非静态方法既可以访问静态也可以访问非静态。

2.静态方法中不可以定义\textbf{this},\textbf{super}关键字。
	
	因为静态优先于对象存在。所以静态方法中不可以出现\textbf{this}字样。

3.主函数是静态的。

\textbf{静态有利有弊}：

利处：对对象的共享数据进行单独空间的存储，节省空间的内存，没有必要每一个对象中都存储一份。

弊端：生命周期过长。

	  访问出现局限性。（静态虽好，只能访问静态。）



\lstinputlisting[language = Java]{../java/StaticDemo.java}
\subsubsection{main函数}
主函数是一个特殊的函数，作为程序的入口，可以被jvm调用。

主函数的定义：

\textit{public}：代表这该函数的访问权限是最大的。

\textit{static}：代表这主函数随着类的加载就已经存在了。

\textit{void}：主函数没有具体的返回值。

\textit{main}：不是关键字，但是一个特殊的单词，可以被jvm识别。

(String[] args):函数的参数，参数类型是一个数组，该数组中的元素是字符串。也可以称作字符串类型的数组。

主函数的固定格式：jvm识别。
jvm在调用主函数时，传入的是new String[0];
\lstinputlisting[language = Java]{../java/MainDemo.java}
\subsubsection{静态的使用}
什么时候使用静态？

要从两方面下手：

因为静态修饰的内容有成员变量和函数。

什么时候定义静态变量（类变量）呢？

当对象中出现共享数据时，该数据被静态所修饰。
对象中的特有数据要定义成非静态寻在于堆内存中。

什么时候定义静态函数呢？

当功能内部没有访问到非静态数据(对象的特有数据)，那么该功能可以定义成静态的。

\textbf{一个静态应用的例子}
\lstinputlisting[language = Java]{../java/ArrayTool.java}
\lstinputlisting[language = Java]{../java/ArrayToolDemo.java}

设置class文件按路径

\textit{set classpath=.;c\\:\\myclass}
\subsubsection{生成说明文档}

\textit{javadoc -d ~/Document/java -author -version ArrayTool.java}
\subsubsection{静态代码块}

静态代码块特点:随着类的加载而执行，只执行一次，并且只执行一次，优先于主函数执行。

用于给类进行初始化的。

运行优先顺序：静态代码块~$\geq$~ 构造代码块~$\geq$~ 构造函数
\lstinputlisting[language = Java]{../java/StaticCodeDemo.java} 
\subsubsection{对象初始化过程}

\textbullet 因为new用到了Person.class，所以会先找到Person.class文件并加载到内存中。

\textbullet 执行该类中的static代码块，如果有的话，给Person.class类进行初始化。

\textbullet 在堆内存中开辟空间，分配内存地址。

\textbullet 在堆内存中建立对象的特有属性，并进行默认初始化。

\textbullet 对属性进行显示初始化。

\textbullet 对对象进行构造代码块初始化。

\textbullet 对对象进行对应的构造函数初始化。

\textbullet 将内存地址付给栈内存中的p变量。

对象初始化过程如下图所示：
\begin{figure}[ht]
\centering
\includegraphics[width = 12cm]{../Dia/duixiang_chushi.jpeg}
\caption{对象初始化过程}
\end{figure}

\lstinputlisting[language = Java]{../java/PersonDemo.java}
\subsubsection{对象调用成员过程}
\begin{figure}[ht]
\centering
\includegraphics[width = 12cm]{../Dia/duixiang_dycy.jpeg}
\caption{对象成员调用过程}
\end{figure}
\subsubsection{单例设计模式}

单例设计模式：解决一个类在内存只存在一个对象。

想要保证对象唯一。
\textbullet 为了避免其他程序过多的建立该类对象，先禁止其他程序建立该类对象。

\textbullet 还为了让其他程序可以访问到该类对象，只好在本类中，自定义一个对象。

\textbullet 为了方便其他程序对自定义对象的访问，可以对外提供一些访问的方式。

这三步怎样用代码代替
\textbullet 将构造函数私有化。

\textbullet 在类中创建一个本类对象。

\textbullet 提供一个方法可以获取到该对象。

对于单例模式的内存运作过程如下图：
\begin{figure}[ht]
\centering
\includegraphics[width = 12cm]{../Dia/SingleDemo.jpeg}
\caption{单例模式的内存运作过程}
\end{figure}
\lstinputlisting[language = Java]{../java/SingleDemo.java}
\subsubsection{单例设计模式2}

饿汉式：就是上一节提到的，先初始化对象。

懒汉式：对象方法被调用时，才初始化，也叫做对象的延时加载。

\textbf{开发时，定义单例，建议使用饿汉式}。
\lstinputlisting[language = Java]{../java/SingleDemo2.java}
\subsubsection{继承概述}
\textbf{继承}：

1.提高代码的复用性。

2.让类与类之间产生了关系，有了这个关系，才有了多台的特性。

\textbf{注意}：千万不要为了获取其他类的功能，简化代码而继承，必须是类与类之间有所属关系才可以继承。

Java语言中：Java只支持单继承，不支持多继承。

因为多继承容易带来安全隐患：当父类中定义了相同的功能，当功能内容不同时，不确定要运行哪一个。但是Java保留了这种机制。并用另一种体现形式来完成表示，就是多实现。

java支持多层继承。也就是一个继承体系。如何使用一个继承体系中的功能呢？

想要使用继承体系，先查阅体系中父类的描述。因为父类中定义了该体系中的共性功能。通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了。

在具体调用时，要创建最子类对象。因为有可能父类不能创建对象，二是创建子类对象可以使用更多的功能包括基本的也包括特有的。

简单一句话：查阅父类功能，创建子类对象使用功能。
\lstinputlisting[language = Java]{../java/ExtendsDemo.java}
\subsubsection{子父类中变量、函数和构造函数的特点}

子父类出现后，类成员的特点：

类中成员

\textbullet 变量

\textbullet 函数

\textbullet 构造函数

1.变量

如果子父类中出现了非私有的同名成员变量时，子类要访问本类中的变量用this，
子类要访问父类中的同名变量，用super。

\textbullet super的使用和this几乎一致。this代表的是本类对象的引用。super代表的是父类对象的引用。

2.子父类中的函数（覆盖：重写）

当子类出现和父类一模一样的函数时，当子类对象调用该函数，会运行子类函数的内容。如同父类函数被覆盖一样。这种情况时函数的另一个特性：重写（覆盖）。

当子类继承父类，沿袭了父类的功能到子类中，子类虽具有该功能，但是功能的内容却和父类不一致，这是，没有必要定义新功能，而是使用覆盖特性，保留父类的功能定义，并重写功能内容。

覆盖：

\textbullet 子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖。

\textbullet 静态只能覆盖静态。

\textbf{记住}：

重载：只看同名函数的参数列表

重写：子类父类方法要一模一样，包括返回值类型。
\lstinputlisting[language = Java]{../java/ExtendsDemo2.java}

3.子父类中的构造函数

在对子类对象进行初始化时，父类的构造函数也会运行。
那是因为子类的构造函数默认第一行有一条隐式的语句 super();
super();回访父类中空参数的构造函数，而且子类中所有的构造函数第一行都是super();

为什么子类一定要回访父类中的构造函数。

因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要查看父类是如何对这些数据进行初始化的。

所以子类在对象初始化时，要先访问以下父类中的构造函数。如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。

\textbf{注意：}super语句一定定义在子类构造函数的第一行。

以上过程也叫做子类的实例化过程。

\textbf{结论}

\textbullet 子类的所有构造函数，默认都会访问父类中空参数的构造函数。

\textbullet 因为子类每一个构造函数的第一行都有一句隐式的super();

\textbullet 当父类中没有空参数的构造函数时，子类必须手动通过super或this语句的形式来指定要访问父类中的构造函数。

当然：子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数。

this super 不能同时在构造函数中，因为不能同时在第一行，因为初始化动作要先做。

\lstinputlisting[language = Java]{../java/ExtendsDemo4.java}
\subsubsection{final关键字}
final：最终。作为一个修饰符。

\textbullet 可以修饰类，变量，函数。

\textbullet 被final修饰的类不可以被继承。为了避免被继承，避免被子类复写功能。

\textbullet 被final修饰的变量是一个常量，只能赋值一次，既可以修饰成员变量，又可以修饰局部变量。

挡在描述事物时，一些数据的出现是固定的，那么这时为了增强阅读性，都给着这些值起个名字，方便于阅读。而这个值不需要改变，所以加上final修饰.作为常量：常量的书写规范所有字母都大写,如果由多个单词组成,单词通过\_连接。

\textbullet 内部类定义在类中的局部位置上时，只能访问该局部被fianl修饰的局部变量。
\lstinputlisting[language = Java]{../java/FinalDemo.java}
\subsubsection{抽象类}

当多个类出现相同功能，但是功能主体不同，这是可以进行向上抽取。这时，只抽取功能定义，而不抽取功能主体。

抽象：看不懂的意思。

抽象的特点：

\textbullet 抽象方法一定定义在抽象类中。

\textbullet 抽象方法和抽象类都必须被abstract关键字修饰。

\textbullet 抽象类不可以用new创建对象。因为调用抽象方法没有意义。

\textbullet 抽象类中的抽象方法要被使用，必须由子类复写其所有的抽象方法后，建立对象调用。

\textbf{如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。}

抽象类和一般类没有太大的不同。该类如何描述事物就如何描述事物，只不过该事物出现了一些看不懂的东西。这些不确定的部分也是该事物的功能，需要明确出来，但是无法定义主体。通过抽象方法来表示。

抽象类比一般类多了抽象函数。就是在类中可以定义抽象方法。

\textbf{抽象类不可以实例化。}

\textbf{特殊：}抽象类中可以不定义抽象方法,这样做仅仅是不让该类建立对象。
\lstinputlisting[language = Java]{../java/AbstractDemo.java}

一个抽象类的练习
\lstinputlisting[language = Java] {../java/AbstractTest.java}

\subsubsection{模板方法模式}

需求：获取一段程序运行时间。

原理：获取程序开始和结束事件相减即可

获取时间：System.currectTimeMillis();

当代码完成优化后，就可以解决这类问题。

这种方式为模板方法设计模式。

什么是模板方法？

在定义功能时，功能的一部分是确定的，但有一部分是不确定的，而确定的部分使用不确定的部分，那么这时就将不确定的部分暴露出去，又该类的子类去完成。	

\lstinputlisting[language = Java]{../java/TemplateDemo.java}
\subsubsection{接口}

接口：初期理解，可以认为一个特殊的抽象类。当类中的方法都是抽象的，该类可以通过接口的形式来表示。

class 用于定义类。

interface 用于定义接口。

接口在定义时，格式特点在于：

1.接口中常见的定义:常量，抽象方法。

2.接口中的成员都有固定的修饰符。

\quad \textbullet 常量：public static final

\quad \textbullet 方法：public abstract

\textbf{记住：}接口中的成员都是public的。

接口：是不可以创建对象的.因为有抽象方法。需要被子类实现，子类对接口中的抽象
方法全部覆盖后，子类才可以实例化。否则子类是一个抽象类。

接口可以被类多实现，也是对多继承不支持的转换形式，Java支持多实现。

接口与接口之间支持继承，多继承。

接口的特点:

\textbullet 接口是对外暴露的规则。

\textbullet 接口时程序的功能扩展。降低了耦合性。

\textbullet 接口可以用来多实现。

\textbullet 类与接口的关系是实现关系，而且类可以继承一个类的同时实现多个接口。

\textbullet 接口于接口之间可以有继承关系，也可以有多继承关系。

\lstinputlisting[language = Java]{../java/InterfaceDemo.java}
接口的举例实现。类时is a。是确定有的，接口时like a。时可能有的。当具有接口的功能时，就实现接口。

\lstinputlisting[language = Java]{../java/InterfaceTest.java}
\subsubsection{多态}

\textbullet \textbf{多态的概念}
	
多态：可以理解为事物存在的多种体现形态。

人：男人，女人
动物：猫，狗

猫 x = new 猫();
动物 x = new 猫();

\textbullet \textbf{多态的基本体现}
	
\quad 父类的引用指向自己的子类对象。

\quad 父类的引用也可以接受自己的子类对象。

\textbullet \textbf{多态的前提}

\quad 必须是类与类之间有关系，要么继承，要么实现。通常还得有一个前提：存在覆盖。

\textbullet \textbf{多态的好处}

\quad 多态的出现大大提高了程序的扩展性。

\textbullet \textbf{多态的弊端}

\quad 提高了扩展性，但是只能使用父类的引用访问父类中的成员。

\textbullet 多态的应用

\textbullet \textbf{多态出现代码中的特点(多态使用的注意事项)}
\lstinputlisting[language = Java]{../java/DuoTaiDemo.java}

多态可以同时操作很多对象。建立一个工具类，具有共同的属性，多态产生同一个大类型，通过对大类型的引用，可以操作多个小类型。因此，提高了扩展性。
\lstinputlisting[language = Java]{../java/DuoTaiDemo3.java}

\textbullet \textbf{多态成员中非静态函数的特点：}

\quad 在编译时期：参阅引用型变量所属的类中是否有调用方法。如果有，编译通过，否则，编译失败；

\quad 在运行时期：参阅对象所属的类中是否有调用的方法。

\quad 简单总结就是：成员函数在多态调用时，编译看左边,运行看右边。

\textbullet \textbf{多态中，成员变量的特点：}

\quad 无论编译和运行，都参考左边（引用型变量所属的类）。

\textbullet \textbf{多态中，静态成员函数的特点：}

\quad 无论编译和运行，都参考左边（引用型变量所属的类）。
\lstinputlisting[language = Java]{../java/DuoTaiDemo4.java}

\textbf{实例}
\lstinputlisting[language = Java]{../java/DuoTaiDemo5.java}
\lstinputlisting[language = Java]{../java/DBOperate.java}
\subsubsection{Object类}

Object:是所有对象的直接或者间接父类。该类中定义的肯定是所有对象都具备的功能。

Object类中已经提供了对对象是否相同的比较方法。

如果自定义类中也有比较相同的功能，没有必要重新定义。只要沿袭父类的功能，建立自己特有的比较内容，这就是覆盖。
\lstinputlisting[language = Java]{../java/ObjectDemo.java}
\subsubsection{内部类}

\textbf{内部类的访问规则}

\textbullet 内部类可以直接访问外部类中的成员，包括私有private。之所以可以直接访问外部类中的成员，是因为内部类中持有了一个外部类的引用，格式：外部类名.this

\textbullet 内部类可以被私有private修饰（成员位置上）

\textbf{访问格式：}

\textbullet 当定义内部类在外部类的成员位置上时，而且非私有，可以在外部其他类中，直接建立内部对象。

格式：外部类名.内部类名 变量名 = 外部类对象.内部类对象;

\qquad Outer.Inner in = new Outer().new Inner();

\textbullet 当内部类在成员位置上，就可以被成员修饰符所修饰。比如：

private:将内部类在外部类中进行封装。

static:内部类就具备static特性。当内部类被static修饰后，只能访问外部类中的static成员。出现了访问局限。

当其他外部类中，如何直接访问static类中的非静态成员呢？

new Outer.Inner().function();

在其他外部类中，如何直接访问static类中的静态成员呢？

new Outer.Inner.function();

注意：当内部类中定义了静态成员，该类必须是静态的。

	当外部类中的静态方法访问内部类时，内部类也必须是static的。

当描述事物时，事物的内容中还有事物，该事物用内部类来描述。因为内部事物在使用外部事物的内容。
\lstinputlisting[language = Java]{../java/InnerClassDemo.java}

\textbf{内部类被定义在局部时}

\textbullet 不可以被成员修饰符修饰。局部内部类不能被静态和私有修饰。

\textbullet 可以访问外部类中的成员，因为还持有外部类的引用。但是不可以访问它所在局部中的变量，只能访问被final修饰的局部变量。	
\lstinputlisting[language = Java]{../java/InnerClassDemo3.java}
\subsubsection{匿名内部类}

\textbullet 匿名内部类其实就是内部类的简写格式。

\textbullet 定义内部类的前提：内部类必须继承一个类或者实现接口。

\textbullet 匿名内部类的格式：new 父类或者接口(){定义子类的内容}

\textbullet 其实匿名内部类就是一个匿名子对象。而且这个对象有点胖，可以理解为带内容的对象。

\textbullet 匿名内部类中定义的方法最好不要超过3个。

\lstinputlisting[language = Java]{../java/InnerClassDemo4.java}

\textbf{实例}
\lstinputlisting[language = Java]{../java/InnerClassTest.java}
\subsection{异常}
\subsubsection{异常的概述}

异常：就是程序在运行时出现的不正常情况。

异常由来：问题也是现实生活中一个具体的事物，也可以通过java的形式进行描述，并封装成对象。其实就是java对不正常的情况进行描述的对象体现。

对于问题的划分：两种：一种时严重的问题，一种是非严重的问题。

\textbullet 对于严重的，java通过Error类进行描述。

\qquad 对于Error一般不编写针对性的代码对其进行处理。

\textbullet 对于非严重的，java通过Exception类进行描述。

\qquad 对于Exception可以使用针对性的处理方式进行处理。

无论Error或者Exception都有一些共性内容。比如：不正常情况的信息，引发原因等。

\textit{Throwable}

\qquad |--\textit{Error}

\qquad |--\textit{Exception}
\subsubsection{异常的处理}

\textbullet java提供了特有的语句进行处理。

try\{

\qquad 需要被检测的代码

\}

catch (异常类 变量)\{

\qquad 处理异常的代码;(处理方式)

\}

finally \{

\qquad 一定会执行的语句

\}

\textbullet 对捕获的异常对象进行常见方法操作。

\qquad String getMessage();获取异常信息。

函数上声明异常。

便于提高安全性，让调用处进行处理。不处理编译失败。

对多异常的处理。

\textbullet 声明异常时，建议声明更为具体的异常，这样处理的可以更具体。

\textbullet 对方声明有几个异常，就对应有几个catch块，不要定以多余的catch块。
如果多个catch块中的异常出现继承关系，父类异常catch放在最下面。

建议在进行catch处理时，catch中一定要定义成具体处理方式。不要简单的定义一句 e.printStackTrace(),也不要简单的就书写一条输出语句。
\lstinputlisting[language = Java]{../java/ExceptionDemo.java}

\subsubsection{自定义异常}

因为项目中会出现特有的问题，而这些问题并为被java描述，并封装对象。所以对于这些特有的问题可以按照java对问题封装的思想，将问题进行自定义的异常封装。

自定义异常。

需求：在本程序中，对于除数是负数，也视为是错误的是无法进行运算的。那么就需要对这个问题进行自定义描述。

当在函数内部出现了throw抛出异常对象，那么就必须给出对应的处理动作。要么在内部try，catch处理。要么在函数上声明调用这处理。

一般情况下，函数内出现异常，函数上需要声明。

发现打印的结果只有异常的名称，却没有异常的信息。因为自定义的异常并未定义信息。

如何定义异常信息呢？

因为父类中已经把异常信息的操作都完成了。所以子类只要在构造时，将异常信息传递个父类通过super语句。

\textbf{自定义异常：}必须是自定义类继承Exception。

继承Exception的原因：异常体系有一个特点：因为异常类和异常对象都需要被抛出。他们都具有可抛性。这个可抛性时Throwable这个体系中的多有特点。

只有这个体系中的类和对象才可以被throws和throw操作。

throws和throw的区别：

\textbullet throws 使用在函数上；throw 使用在函数内。

\textbullet throws 后面跟的是异常类，可以跟多个。用逗号隔开；throw后面跟的是异常对象。

\lstinputlisting[language = Java]{../java/ExceptionDemo3.java}

\subsubsection{RuntimeException异常}

Exception中有一个特殊的子类异常RuntimeException运行时异常。

如果在函数内容抛出该异常，函数上可以声明，编译一样通过。

如果在函数上声明改异常，调用者可以不用进行处理。编译一样通过。

之所以不再函数上声明，是因为不需要让调用者处理。该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，由程序员对代码进行修正。

自定义异常时：如果该异常的发生，无法继续进行运算，就让自定义异常继承RuntimeException。

对异常分两种：

1.编译时被检测的异常。

2.编译时不被检测的异常。（运行时异常。RuntimeException以及其子类）。
\lstinputlisting[language = Java]{../java/ExceptionDemo4.java}
\subsubsection{finally代码块}

finally代码块：定义一定执行的代码。通常用于关闭资源。	
\lstinputlisting[language = Java]{../java/ExceptionDemo5.java}

\subsubsection{处理语句的其他格式}

问题被解决，可以不用声明。有catch就是问题解决。没有catch就是没有处理。

记住一点：catch是用于处理异常的。如果没有catch就代表没有被处理，如果该异常是检测性异常，那么必须声明

\textbullet 第一个格式

\textit{try} \{
		
	
	
	\}

\textit{catch} \{
	


	\}

\textbullet 第二种格式

\textit{try}\{

\}

\textit{catch}()\{

\}

\textit{finally}\{

\}

\textbullet 第三种格式

\textit{try} \{

\}

\textit{finally} \{

\}
\lstinputlisting[language = Java]{../java/ExceptionDemo6.java}

\subsubsection{覆盖时的异常特点}

异常在子类覆盖中的体现。

\textbullet 子类在覆盖父类时，如果父类的方法抛出异常,那么子类的覆盖方法，只能抛出父类的异常或该异常的子类，或者不抛。

\textbullet 如果父类的方法抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集。

\textbullet 如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时也不可以抛出异常。如果子类方法发生了异常就必须进行try处理，绝对不能抛。

\lstinputlisting[language = Java]{../java/ExceptionDemo7.java}

\subsubsection{实例}
\textbf{毕老师用电脑上课}

开始思考上课中出现的问题。

\textbullet 电脑蓝屏

\textbullet 电脑冒烟

要对问题进行描述，封装成对象。可是当冒烟发生后，会出现讲课进度无法继续。出现了讲师的问题：可是计划无法完成。

\lstinputlisting[language = Java]{../java/ExceptionTest.java}

\textbf{圆形和长方形面积}

有一个长方形和圆形，都可以获取面积，如果出现非法值，视为获取面积时出现的问题。问题通过异常来表示。

注意：先要对这个程序进行基本的设计。

\lstinputlisting[language = Java]{../java/ExceptionTest1.java}
\subsubsection{异常总结}

\textbf{异常：}是对问题的描述。将问题进行对象的封装。

\textbf{异常体系:}

\textit{Throwable}

\qquad |-- \textit{Error}

\qquad |-- \textit{Exception}

\qquad \qquad |-- \textit{RuntimeException}

\textbf{异常体系的特点：}异常体系中的所有类以及建立的对象都具有可抛性。也就是说可以被throw和throws关键字所操作。只有异常体系具备这个特点。

\textbf{throw和throws的特点：}

\textbullet throw定义在函数内，用于抛出异常对象。

\textbullet throws定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开。

当函数内容有throw抛出异常对象，并未进行异常处理。必须要在函数上声明。否则编译失败。

注意：RuntimeException除外。也就是说，函数内如果抛出的是RuntimeException异常，函数上可以不用声明。

\textbf{异常处理}

如果函数声明了异常，调用者需要进行处理。处理方式可抛可try。

异常有两种：

\textbullet 编译时被检测异常。该异常如果在编译时没有处理（没有抛也没有try），编译失败。该异常被标识，代表着可以被处理。

\textbullet 运行时异常（编译时不检测）。在编译时，不需要处理，编译器检查。该异常发生，建议不处理，让程序停止，需要对代码进行修正。

\textbf{异常处理语句}

\textit{try}\{

\qquad 需要检测的代码

\}

\textit{catch}\{

\qquad 处理异常的代码

\}

\textit{finally}\{

一定会执行的代码

\}

有三种结合格式：

\textbullet 第一种

\textit{try}\{

\}

\textit{catch}\{

\}

\textbullet 第二种

\textit{try}\{

\}

\textit{finally}\{

\}

\textbullet 第三种

\textit{try}\{

\}

\textit{catch}\{

\}

\textit{finally}\{

\}

注意：

\textbullet finally中定义的通常是关闭资源代码。因为资源必须要释放。

\textbullet finally只有一种情况不会执行。当执行到System.out.exit(0);finally不会执行。

\textbf{自定义异常}

定义类继承Exception或者RuntimeException

\textbullet 是为了让该自定义类具备可抛性。

\textbullet 让该类具备操作异常的共性方法。

当要定义自定义异常的信息时，可以使用父类已经定义好的功能。将异常信息传递给父类的构造函数。
\begin{lstlisting}[language = Java]
class MyException extends Exception{
	MyException(String message) { 
			super(message);
	}
}
\end{lstlisting}

自定义异常：按照java面向对象思想，将程序中出现的特有问题进行封装。

\textbf{异常的好处}

\textbullet 将问题进行封装。

\textbullet 将正常流程代码和问题处理代码相分离，方便于阅读。

\textbf{异常的处理原则}

\textbullet 处理方式有两种：try或者throws

\textbullet 调用到抛出异常功能时，抛出几个，就处理几个。一个try对应多个catch

\textbullet 多个catch，父类的catch放到最下面。

\textbullet catch内，需要定义针对性的处理方式。不要简单的定义printStackTrace，输出语句也不要写。

当捕获到的异常，本功能处理不了时，可以继续在catch中抛出。

\begin{lstlisting}[language = Java]
try{
	throw new AException();
}
catch(AException) {
	throw e;
}
\end{lstlisting}

如果该异常处理不了，但并不属于该功能出现的异常。可以将异常转换后，再抛出和该功能相关的异常。

或者异常可以处理，但需要将异常产生的和本功能相关的问题提供出去。让调用者知道并处理。也可以将捕获异常处理后，转换新的异常。
\begin{lstlisting}[language = Java]
try{
	//对AException处理
	throw new AException();
}
catch(AException) {
	throw new BException();
}
\end{lstlisting}
比如：汇款的例子

\textbf{异常的注意事项}

在子父类覆盖时：

\textbullet 子类抛出的异常必须是父类异常的子类或者子集。

\textbullet 如果父类或者接口没有抛出异常时，子类覆盖出现异常，只能try不能抛。

\textbf{参阅}

\textbullet ExceptionTest.java 老师用电脑上课。

\textbullet ExceptionTest1.java 图形面积。

\subsection{包}

为了简化类名的书写，使用一个关键字，import。import导入的时包中的类。
建议不要写通配符*，需要用到哪个包的那个类就导入那个类。

建议报名不要重复，可以使用url来完成定义.因为url是唯一的。

类名的全名为 包名.类名

packa包不再当前目录下，需要设置classpath告诉jvm去哪里找指定的packa包。

类公有后，被访问的成员也要公有才可以被访问。

\textbf{总结：}

\textbullet 包与包之间进行访问，被访问的类以及类中的成员，需要public修饰。

\textbullet 不同包中的子类可以直接访问父类中被protected修饰的成员.

\textbullet 包与包之间可以使用的权限只有两种，public和protected。

编译命令：

\textit{javac -d . PackDemo.java}

\begin{tabular}{c|cccc}
%\hline
           &public &protected &default &private \\ \hline
同一个类中 &ok     &ok        &ok      &ok \\
同一个包中 &ok     &ok        &ok      &no \\
子类       &ok     &ok        &no      &no \\
不同包中   &ok     &no        &no      &no \\
\end{tabular}


\lstinputlisting[language = Java]{../java/PackageDemo.java}
\lstinputlisting[language = Java]{../java/DemoA.java}
\lstinputlisting[language = Java]{../java/DemoB.java}
\lstinputlisting[language = Java]{../java/DemoC.java}

\subsubsection{Jar包}

\textbullet 将多个编译完成的class文件归档到一个Jar包中。

\textit{jar -cf haha.jar packa pack}

\textbullet 查看Jar包内容

\textit{jar -tf haha.jar}

\textbullet 将数据进行重定向

\textit{jar -cvf a.jar$>~/$Document}

\subsection{多线程}
\subsubsection{多线程的实现方式}
进程：是一个正在执行中的程序。

\qquad 每一个进程执行都有执行的顺序。该顺序就是一个执行路径。

线程：就是一个进程中独立的控制单元。

\qquad 就是进程中一个独立的控制单元。
线程在控制着进程的执行。

一个进程至少有一个线程。

java VM 启动的时候会有意个进程java.exe

该进程至少有一个线程负责java程序的执行。而且这个线程运行的代码存放在main方法中。该线程称之为\textbf{主线程}。

扩展：其实更细节说明jvm，jvm启动不止一个线程，还有负责垃圾回收机制的线程。

1.如何在自定义的代码中定义一个线程。

通过API的查找，java已经提供了对线程这类的描述，就是Thread类。

\textbf{创建线程的第一种方式，继承Thread类。}

步骤：

\textbullet 定义类继承Thread类。

\textbullet 复写Thread类中的run方法。
	
\qquad 目的：将自定义的代码存储在run方法中，让线程运行。

\textbullet 调用线程的start方法，该方法有两个作用：启动线程，调用run方法。

发现运行结果每一次都不同。因为多个线程都获取CPU的执行权。cpu执行到谁，谁就运行。

明确一点，在某一时刻，只能有一个程序在运行（多核除外）。CPU在做着快速切换，以达到看上区时同时运行的结果。

我们可以形象的把多线程的运行比喻万恶为相互抢夺cpu的执行权。这就是多线程的一个特性：随机性。谁抢到，谁执行，至于执行多长，cpu说了算。

为什么要覆盖run方法呢？

Thread类用于描述线程。该类就定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。也就是说，Thread中的run方法，用于存储线程要运行的代码。

\lstinputlisting[language = Java]{../java/ThreadDemo.java}

练习：

创建两个线程，和主线程交替运行。

原来线程都有自己默认的名称。

Thread-编号，该编号从0开始。

static Thread currentThread():获取当前线程对象。

getName():获取线程名称。

设置线程名称：setName或者构造函数。

\lstinputlisting[language = Java]{../java/ThreadTest.java}

\textbf{创建线程的第二种方式：实现Runnable接口}

步骤：

\textbullet 定义类实现Runnable接口

\textbullet 覆盖Runnable接口中的run方法。

\qquad 将线程要运行的代码存放在该run方法中。

\textbullet 通过Thread类建立线程对象。

\textbullet 将Runnable接口的子类对象作为实际参数传递给Thread的构造函数。

\qquad 为什么要将Runnable接口的子类对象传递给Thread构造函数。

\qquad 因为自定义的run方法所属的对象是Runnable接口的子类对象。

\qquad 所以要让线程去执行指定对象的run方法。就必须明确run方法所属的对象。

\textbullet 调用Thread类的start方法，开启线程，并调用Runnable接口的run方法。

实现方式和继承方式有什么区别？

实现方式的好处：避免了单继承的局限性。

在自定义线程时，建议使用继承方式。

两种方式的区别：

继承Thread：线程代码存放在Thread子类的run方法中。

实现Runnable：线程代码存放在接口子类的run方法中。

\subsubsection{多线程的锁-同步代码块}

在下面例子中，打印出0，-1，-2等错票。

多线程的运行出现了安全问题。

问题发生的原因：

当多条语句在操作同一个线程的共享数据时，一个线程对多条语句值执
行了一部分，还没执行完，另一个线程参与进来执行。导致共享数据的错误。

解决的办法：

对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中其他线程不可以参与执行。

Java对多线程的安全问题提供了专业的解决方式，这就是\textbf{同步代码块}。

\textit{synchronized(Object)} \{

\qquad 需要被同步的代码

\}

对象如同锁，持有锁的线程可以在同步中执行。

没有持有锁的线程及时获得cpu的执行权，也进不去，因为没有获取锁。

同步的前提:

\textbullet 必须要有两个或者两个以上的线程。

\textbullet 必须是多个线程使用同一个锁。

必须保证同步中只能有一个线程在运行。

好处：解决了多线程的安全问题。

弊端：多个线程需要判断锁，较为消耗资源。
\lstinputlisting[language = Java]{../java/TicketDemo.java}

\subsubsection{多线程的锁--同步函数}

如何找到问题：

\textbullet 明确那些代码时多线程运行代码。

\textbullet 明确共享数据。

\textbullet 明确多线程运行代码中那些语句时操作共享数据的。

\lstinputlisting[language = Java]{../java/BankDemo.java}

同步函数使用的哪一个锁？

函数要被对象调用，那么函数都有一个所属对象的引用，就是this。所以同步函数使用的锁时this。

通过该程序进行验证。

使用两个线程来买票。

一个线程在同步代码块中。

一个线程在同步函数中。

都在执行买票动作。

\lstinputlisting[language = Java]{../java/ThisLockDemo.java}

如果同步函数被静态修饰后，使用的锁是是什么？

通过验证，发现不再是this。因为静态方法中也不可以定义this。

静态进内存时，内存中没有本类对象，但是一定有该类对应的字节码文件对象。

类名.class 该对象的类型是class。

静态的同步方法：使用的锁时该方法所在类的字节码文件对象。 类名.class

\lstinputlisting[language = Java]{../java/StaticMethodDemo.java}

设计模式：先初始化对象。成为饿汉式。Single一进内存，就已经创建好了对象。

\textit{class Single} \{

\qquad \textit{private Static Single = s = new Single();}

\qquad \textit{private Single()}\{\}

\qquad \textit{public static Single getInstance() }\{

\qquad \textit{return s;}

\qquad \}

\}

懒汉式的形式：
\lstinputlisting[language = Java]{../java/SingleDemo2.java}

\subsubsection{死锁}

同步嵌套同步，所却不同

\lstinputlisting[language = Java]{../java/DeadLockDemo.java}

\subsubsection{线程间通信}

就是多个线程在操作同一个资源，但操作的动作不同。

wait();

notify();

notifyAll();

都使用在同步中，因为对持有监视器（锁）的线程操作。

所以要使用在同步中，因为只有同步才具有所得概念。

为什么这些操作线程的方法要定义在Object类中呢？

因为这些方法在操作同步中线程时，都必须要标示他们所操作线程持有的锁，只有同一个锁上的被等待线程，可以被同一个锁上的notify唤醒。不可以对不同锁中的线程进行唤醒。也就是说等待和唤醒必须是同一个锁。

而锁可以是任意对象，所以可以被任意对象调用的方法定义在Object类中。

\lstinputlisting[language = Java]{../java/InputOutputDemo.java}

对上面的代码进行优化。

\lstinputlisting[language = Java]{../java/InputOutputDemo2.java}

\subsubsection{notifyAll——唤醒对方线程}

对于多个生产者消费者。

为什么要定义while判断标记。

原因：让被唤醒的线程再一次判断标记。

为什么要定义notifyAll，

因为需要唤醒对方线程。

因为只用notify，容易出现值唤醒本方线程的情况。导致程序中的所有线程都等待。

\lstinputlisting[language = Java]{../java/ProducerConsumerDemo.java}

\subsubsection{Lock的应用}

JDK1.5中提供了多线程升级解决方案。

将同步Synchronized替换成显式Lock操作。

将Object中的wait，notigy，notifyAll替换成了condition对象。

该对象可以通过Lock锁进行获取。

在该事例中，实现了本方只唤醒对方的操作。

\lstinputlisting[language = Java]{../java/ProducerConsumerDemo2.java}

\subsubsection{停止线程}

stop方法已经过时。

如何停止线程呢？

只有一种，run方法结束。

开启多线程运行，运行代码通常是循环结构。

只要控制住循环，就可以让run方法结束，也就是线程结束。

特殊情况：

当先成处于冻结状态。就不会读取到标记。那么线程就不会结束。

当没有指定的方式让冻结的线程回复到运行状态时，这时需要对冻结进行清除。
强制让线程恢复到运行状态中来。这样就可以操作标记让线程结束。

Thread类中提供了方法interrupt();

\lstinputlisting[language = Java]{../java/StopThreadDemo.java}

\subsubsection{守护线程}

Deamon方法：前台线程结束，后台线程（守护线程）自动结束。见上例。

\subsubsection{Join方法}

当A线程执行到了B线程的.join()方法时，A就会等待。等B线程都执行完，A才会执行。

join可以用来临时加入线程执行。

\lstinputlisting[language = Java]{../java/JoinDemo.java}

\subsubsection{优先级\&yield方法}

通过setPriority()定义优先级。看上例。

\subsubsection{开发时线程的常见写法}

\lstinputlisting[language = Java]{../java/ThreadTest2.java}

\subsection{字符串}
\subsubsection{概述}
\textbullet 字符串最大特点：一旦被初始化就不可以被改变。

\textbullet String类复写了Object类中的equals方法，该方法用于判断字符串是否相同。

\lstinputlisting[language = Java]{../java/StringDemo.java}
\subsubsection{字符串操作方法}

String类是用于描述字符串事物。那么它就提攻了多个方法对字符串进行操作。

$\bigstar$  获取。

\qquad \textbullet  字符串中包含的字符数，也就是字符串长度。

\qquad \quad int length():获取长度。

\qquad \textbullet  根据位置获取位置上的某个字符。

\qquad \quad char charAt(int index)

\qquad \textbullet  根据字符获取该字符在字符串中的位置

\qquad \quad int indexOf(int ch):返回ch在字符串中第一次出现的位置。

\qquad \quad int indexOf(int ch, int fromIndex):从fromIndex指定位置开始，获取ch在字符串中出现的未知。

\qquad \quad int indexOf(String str):返回的str在字符串中第一次出现的位置。

\qquad \quad int indexOf(String str, int fromIndex):从fromIndex指定位置开始，获取str在字符串中出现的位置。

\qquad \quad int lastIndexOf(String str)

$\bigstar$ 判断

\qquad \textbullet 字符串中是否包含一个子串。

\qquad \quad boolean contains(str);

\qquad \quad 特殊之处：indexOf(str):可以索引str第一次出现位置。

\qquad \quad 如果返回-1，表示str不再字符串存在。所以也可以用于对指定字符串判断是否包含。

\qquad \quad if(str.indexOf("aa)!==-1):该方法既可以判断又可以获取出现的位置。

\qquad \textbullet 字符串中是否有内容

\qquad \quad boolean isEmpty():原理就是判断长度是否为0."" null

\qquad \textbullet 字符串是否以指定内容开头。

\qquad \quad boolean starsWith(str);

\qquad \textbullet 字符窜是否以指定内容结尾。

\qquad \quad boolean endsWith(str);

\qquad \textbullet 判断字符串的内容是否相同。复写了Object类中的equals方法。

\qquad \quad boolean equals(str);

\qquad \textbullet 判断内容是否相同，并忽略大小写。

\qquad \quad boolean equalsIgnoreCase();

$\bigstar$ 转换

\qquad \textbullet 将字符数组转成字符串。

\qquad \quad 构造函数：String(char[])

\qquad \qquad \quad String(char[], offset, count):将字符数组的一部分转成字符串。

\qquad \quad 静态方法：

\qquad \qquad \quad static String copyValueOf(char[]);

\qquad \qquad \quad static String copyValueOf(char[] data, int offset, int count);

\qquad \qquad \quad static String valueOf(char[]);

\qquad \textbullet 将字符串转成字符数组。

\qquad \quad char[] toCharArray()：将字符串转成字符数组。

\qquad \textbullet 将字节数组转成字符串

\qquad \quad byte[] getBytes();

\qquad \textbullet 将基本数据类型转成字符串。

\qquad \quad static String valueOf(int );

\qquad \quad static String valueOf(double);

\qquad \quad 3+""//String.valueOf(3);

\qquad \quad 字符串和字节数组在转换过程，是可以指定编码表的。

$\bigstar$ 替换

\qquad \quad String replace(oldchar, newchar);

$\bigstar$ 切割

\qquad \quad String[] split(regex);

$\bigstar$ 子串。获取字符串中的一部分。

\qquad \quad String substring(begin);

\qquad \quad String substring(begin, end);

$\bigstar$ 转换，取出空格，比较。

\qquad \textbullet 将字符串转换成大写或小写

\qquad \quad String toUpperCase();

\qquad \quad String toLowerCase();

\qquad \textbullet 将字符串两端的多个空格去除。

\qquad \quad String trim();

\qquad \textbullet 对两个字符串进行自然顺序的比较。

\qquad \quad int compare(str);

\lstinputlisting[language = Java]{../java/StringMethodDemo.java}

\subsubsection{字符串练习}

\lstinputlisting[language = Java]{../java/StringTest.java}

\lstinputlisting[language = Java]{../java/StringTest3.java}

\subsubsection{StringBuffer\&StringBuilder}

StringBuffer是字符串缓冲区。是一个容器。

\textbf{特点：}

\textbullet 长度是可以变化的。

\textbullet 可以直接操作多个数据类型。

\textbullet 最终会通过toString编程字符串。

C create U update R read D delete

$\bigstar$ 存储

\qquad StringBuffer append():将指定的数据作为参数添加到已有数据结尾处。

\qquad StringBuffer insert(index, 数据):可以讲述据插入到指定index位置。

$\bigstar$ 删除

\qquad StringBuffer delete(start, end):删除缓冲区中的数据，包含start，不包含end。

\qquad StirngBuffer deleteCharAt(index):删除指定位置的字符。

$\bigstar$ 获取

\qquad char charAt(int index)

\qquad int indexOf(String str)

\qquad int lastIndexOf(String str)

\qquad int length()

\qquad String substring(int start, int end)

$\bigstar$ 修改

\qquad StringBuffer replace(start, end, string);

\qquad void setCharAt(int index, char ch);

$\bigstar$ 反转

\qquad StringBuffer reverse();

$\bigstar$ 将缓冲区中的指定数据存储到指定字符数组中。

\qquad void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin);

JDK1.5版本之后出现了StringBuilder

StringBuffer线程同步。

StringBuilder线程不同步。

以后开发建议使用StringBuilder

升级三个因素：

\textbullet 提高效率

\textbullet 简化书写

\textbullet 提高安全性

\lstinputlisting[language = Java]{../java/StringBufferDemo.java}

\subsubsection{基本数据类型包装类}

\begin{tabular}{c|c}
基本数据类型 &包装类\\\hline
byte &Byte \\
short &Short \\
int   &Integer \\
long  &Long \\
boolean &Boolean \\
float &Float \\
double &Double \\
char   &Character 
\end{tabular}

基本数据类型包装类的最常见作用，就是用于基本数据类型和字符串类型之间做转换。

基本数据类型转还成字符串：

\textbullet 基本数据类型+"";

\textbullet 基本数据类型.toString(基本数据类型值);

\qquad 如：Integer.toString(34);//将34整数变成"34";

字符串转成基本数据类型：

\textbullet xxx a = Xxx.parseXxx(String);

\qquad int a = Integer.parseInteger("123");

\qquad double b = Double.parseDouble("12.23");

\qquad boolean b = Boolean.parseBoolean("false");

\qquad Integer i = new Integer("123");

\qquad int num = i.intValue();

十进制转成其他禁止。

\textbullet toBinaryString();

\textbullet toHexString();

\textbullet toOctalString();

其他进制转成十进制。

\textbullet parseInt(String, index);

\lstinputlisting[language = Java]{../java/IntegerDemo.java}

JDK1.5版本之后的新特性。

\textbullet 自动装箱或拆箱

\textbullet 当数值在byte范围内时，对于新特性，如果该数值已存在,不会再开辟新空间。

\lstinputlisting[language = Java]{../java/IntegerDemo1.java}

\subsection{集合框架}
\subsubsection{共性方法和迭代器}

\textbullet add方法的参数类型是Object。以便于接受任意类型的对象。

\textbullet 集合中存储对象时对象的引用（地址）。

什么是迭代器呢？

其实就是集合的取出元素的方式。

下例中包含了其他函数。如isEmpty, removeAll等。
\lstinputlisting[language = Java]{../java/CollectionDemo.java}

\subsubsection{Lsit共性方法h和ListIterator迭代器}

\textit{Collection}

\qquad |-- \textit{List}:元素是有序的，元素可以重复。因为该集合体系有索引。

\qquad \qquad |-- \textit{ArrayList}:底层的数组结构使用的是数组结构。特点在于：查询速度很快。但是增删稍慢。线程不同步。

\qquad \qquad |-- \textit{LinkedList}:底层使用的时链表数据结构。特点：增删速度很快，查询速度稍慢。

\qquad \qquad |-- \textit{Vector}:线程同步。被ArrayList替代。

\qquad |-- \textit{Set}:元素是无序的，元素不可以重复。没有索引。

List: 

特有方法：

增：

add(index, element);

addAll(index, Collection);

删：

remove(index);

改：

set(index, element);

查

get(index);

subList(from, to);

listIterator();

List集合集合特有的迭代器，ListIterator是Iterator的子接口。

在迭代时，不可以通过集合对象的方法操作集合中的元素。因为会发生并发修改异常
ConcurrentModificationException。

所以，在迭代时，只能通过迭代器的方法操作元素，可是Iterator的方法是有限的。
只能对元素进行判断，取出，删除的操作。如果想要其他的操作，如添加，修改等，就需要使用其子接口。ListIterator。

该接口只能通过List集合的ListIterator获取。

\lstinputlisting[language = Java]{../java/ListDemo.java}

\subsubsection{Vector枚举}

枚举就是Vector特有的取出方式。

发现枚举和迭代器很像。

其实枚举和迭代是一样的。

因为枚举的名称以及方法的名称都过长。所以被迭代器取代了。

\lstinputlisting[language = Java]{../java/VectorDemo.java}

\subsubsection{LinkedList}

LinkedList的特有方法：

addFirst();
addLast();

获取元素，但不删除元素

getFirst();
getLast();

获取元素，但有元素被删除。如果集合中没有元素，会出现NoSuchElementExcepiton。

removeFirst();
removeLast()
在JDK1.6c出现了替代方法。

offerFirst();
offerLast();

获取元素，但不删除元素。如果集合中没有元素，会返回null。

peekFirst();
peekLast();

获取元素，但是元素被删除。如果集合中没有元素，会返回null。
pollFirst();
pollLast();

\lstinputlisting[language = Java]{../java/LinkedListDemo.java}

\subsubsection{LinkedList练习}

\lstinputlisting[language = Java]{../java/LinkedListTest.java}

\subsubsection{ArrayList练习}

\textbullet 去除ArrayList集合中的重复元素。

\lstinputlisting[language = Java]{../java/ArrayListTest.java}

\textbullet 将自定义对象作为元素存储到ArrayList集合中，并取出重复元素。

\lstinputlisting[language = Java]{../java/ArrayListTest2.java}

\subsubsection{HashSet}

\textit{|- -Set}:元素无序（存入和取出的顺序不一定一致），元素不可以重复。

\qquad \textit{|- -HashSet}:底层数据结构是哈希表。

\qquad \qquad HashSet是如何保证元素唯一性的？

\qquad \qquad 是通过元素的两个方法，hashCode和equals来完成。

\qquad \qquad 如果元素的HashCode值相同，才会判断equals是否为true。

\qquad \qquad 如果元素的HashCode值不同，不会调用equals();

\qquad \qquad \textbf{注意：}对于判断元素是否存在，以及删除等操作，以来的方法是元素的hashCode和equals方法。

\qquad \textit{|- -TreeSet:}

Set集合的功能和Collection是一致的。

\lstinputlisting[language = Java]{../java/HashSetDemo.java}

\subsubsection{HashSet存储自定义对象}

\textbullet 向HashSet集合中存入自定义对象。姓名和年龄为同一个人（重复元素）。

\lstinputlisting[language = Java]{../java/HashSetTest.java}

\subsubsection{TreeSet}

\textit{Set}:无序，不可以重复元素。

\qquad \textit{|- - HashSet}:数据结构是哈希表，线程是非同步的。

\qquad \qquad 保证元素唯一性的原理，判断元素的hashCode值是否相同。

\qquad \qquad 如果相同，还会继续判断元素的equals方法是否为真。

\qquad \textit{|- - TreeSet}:可以对Set集合中的元素进行排序。、

\qquad \qquad 底层数据结构是二叉树。

\qquad \qquad 保证元素唯一性的依据：

\qquad \qquad compareTo 方法 return 0；；

\textbullet TreeSet排序的第一种方式：让元素自身具备比较性，元素需要实现Comparable接口，覆盖compareTo方法。这种方式也成为元素的自然顺序，或者叫做默认顺序。

\textbullet TreeSet集合的第二种排序方式：当元素自身不具备比较性时，或者具备的比较性不是所需要的。这就需要让集合自身具备比较性。\textbf{集合初始化时，就具备了比较性}

\textbf{记住：排序时，当主要条件相同时，一定判断下一次要条件}

\lstinputlisting[language = Java]{../java/TreeSetDemo.java}

\subsubsection{Comparator比较器排序}

当元素自身不具备比较性，或者具备的比较性不是所需要的。这时需要让容器自身具备比较性。

定义了比较器，将比较器对象作为参数传递给TreeSet集合的构造函数。

两种排序方式都存在时，以比较器为主。

定义一个类，实现Comparator接口，实现compare方法。

\lstinputlisting[language = Java]{../java/TreeSetDemo2.java}
\subsubsection{TreeSet练习}

\textbullet 按照字符串长度排序。字符串本身不具备比较性	。但是他的比较方式不是所需要的。这样就只能使用比较器。

\lstinputlisting[language = Java]{../java/TreeSetTest.java}
\subsection{泛型}
\subsubsection{泛型概述}

泛型：JDK1.5版本以后出现的新特性，用于解决安全问题，是一个安全机制。

好处

\textbullet 将运行时期出现的问题ClassCastException转移到了编译时期。

\qquad 方便于解决问题。让运行时期问题减少，安全。

\textbullet 避免了强制转换的麻烦。

泛型格式：通过<>定义要操作的引用数据类型。

使用java提供对象时，什么时候写泛型呢？

通常通常在集合框架中很常见。只要见到<>就要定义泛型。其实<>就是用来接受类型的。

当使用集合时，将集合中要存储的数据类型作为参数传递到<>括号中即可。

\lstinputlisting[language = Java]{../java/GenericDemo.java}

\subsubsection{泛型使用}
\lstinputlisting[language = Java]{../java/GenericDemo2.java}

\subsubsection{泛型类}

泛型前做法

什么时候定义泛型类？

当类中要操作的引用数据不确定的时候，早期定义Object来完成扩展。现在定义泛型来完成扩展。

\lstinputlisting[language = Java]{../java/GenericDemo3.java}

\subsubsection{泛型函数}

\textbullet 泛型类定义的泛型，在整个类中有效,如果被方法使用，那么泛型类的对象明确要操作的具体类型后，所有操作方法要操作的类型就已经固定了。为了让不同的方法可以操作不同的类型，而且类型还不确定，那么可以将泛型定义在方法上。

\textbullet 特殊之处：静态方法不可以访问类上定义的泛型。如果静态方法操作的引用数据类型不确定，可将泛型定义在方法上。

\lstinputlisting[language = Java]{../java/GenericDemo4.java}
\subsubsection{泛型接口}

将泛型定义在接口上。
\lstinputlisting[language = Java]{../java/GenericDemo5.java}
\subsubsection{泛型限定}

\textbullet \textbf{?} 通配符。也可以理解为占位符。

泛型的限定：

\textbullet ? extends E: 可以接收E类型或者E的子类型。上限。

\textbullet ? super E: 可以接受E类型或者E的父类型。下限。

\lstinputlisting[language = Java]{../java/GenericDemo6.java}
\lstinputlisting[language = Java]{../java/GenericDemo7.java}

\subsection{Map集合}
\subsubsection{Map概述}

Map集合：该集合存储键值对。一对一对往里存。而且要保证键的一致性。

\textbullet 添加

\qquad put(K key, V value);

\qquad putAll(Map);

\textbullet 删除

\qquad clear();

\qquad remove(Object key);

\textbullet 判断

\qquad containsKey();

\qquad containsValue();

\qquad isEmpty();

\textbullet 获取

\qquad get(Object key);

\qquad size();

\qquad values();

\qquad entrySet();

\qquad keySet();


\em{map}

\qquad |--\em{Hashtable}:底层是哈希表数据结构,不可以存入null作为键，null作为值的情况。该机核时线程同步的。JKD1.0。效率低。

\qquad |--\em{HashMap}:底层是哈希表数据结构。允许使用null键null值，该集合是不同步的。JDK1.2。效率高。

\qquad |--\em{TreeMap}:底层是二叉树数据结构。线程不同步。可以用于对Map集合中的键进行排序。和Set很像。Set集合使用了Map集合。

\lstinputlisting[language = Java]{../java/MapDemo.java}
\subsubsection{Map取出方法}

map集合的两种取出方式：

\textbullet Set<k> KeySet:将map中所有的键存入到Set集合。因为Set集合具备迭代器。所以可以通过迭代方式取出所有键，再根据get方法，获取每一个键对应的值。

\textbf{Map集合取出原理}：将map集合转成Set集合。再通过迭代器取出。

\textbullet Set<Map.Entry<k, v> entrySet> entrySet:将map集合中的映射关系存入到了Set集合中,而这个关系的数据类型就是：Map.Entry。


$\bigstar$ 其实Entry也是一个接口，它时Map接口中的一个内部接口。

\lstinputlisting[language = Java]{../java/MapDemo2.java}
\subsubsection{Map练习}
\lstinputlisting[language = Java]{../java/MapTest.java}
\subsubsection{TreeMap练习}
\lstinputlisting[language = Java]{../java/MapTest2.java}
\lstinputlisting[language = Java]{../java/MapTest3.java}
\subsubsection{Map扩展}
$\bigstar$ Map集合：该集合存储键值对。一对一往里存。而且要保证键的唯一性。

\qquad \textbullet 添加

\qquad \qquad put(K key, V value);

\qquad \qquad putAll(Map);

\qquad \textbullet 删除

\qquad \qquad clear();

\qquad \qquad remove(Object key);

\qquad \textbullet 判断

\qquad \qquad containsKey();

\qquad \qquad containsValue();

\qquad \qquad isEmpty();

\qquad \textbullet 获取

\qquad \qquad get(Object key);

\qquad \qquad size();

\qquad \qquad values();

\qquad \qquad entrySet();

\qquad \qquad keySet();

\em{Map}

\qquad |--\textit{Hashtable:}底层是哈希表结构，不可以存入null为键，null为值的情况。该集合时线程同步的。JDK1.0。效率低。

\qquad |--\textit{HashMap}:底层是哈希表数据结构。允许使用null值null键，该集合时不同步的。JDK1.2.效率高。

\qquad |--\textit{TreeMap}:底层是二叉树结构。线程不同步。可以用于给map集合中的键进行排序。和Set很像。Set底层就使用了Map集合。

\lstinputlisting[language=Java]{../java/MapDemo3.java}

\subsubsection{集合框架工具类}
\lstinputlisting[language=Java]{../java/CollectionsDemo.java}

\end{document}










