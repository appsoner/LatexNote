\documentclass[UTF8]{ctexart}
%\usepackage{CJKutf8}
\setCJKmainfont{KaiTi}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\lstset{%  
alsolanguage=Java,  
%language={[ISO]C++},       %language为，还有{[Visual]C++}  
%alsolanguage=[ANSI]C,      %可以添加很多个alsolanguage,如alsolanguage=matlab,alsolanguage=VHDL等  
%alsolanguage= tcl,  
alsolanguage= XML,  
tabsize=4, %  
frame=shadowbox, %把代码用带有阴影的框圈起来  
commentstyle=\color{red!60!blue!90},%浅灰色的注释  
rulesepcolor=\color{red!20!green!20!blue!20},%代码块边框为淡青色  
keywordstyle=\color{blue!90}\bfseries, %代码关键字的颜色为蓝色，粗体  
showstringspaces=false,%不显示代码字符串中间的空格标记  
stringstyle=\ttfamily, % 代码字符串的特殊格式  
keepspaces=true, %  
breakindent=22pt, %  
numbers=left,%左侧显示行号 往左靠,还可以为right，或none，即不加行号  
stepnumber=1,%若设置为2，则显示行号为1,3,5，即stepnumber为公差,默认stepnumber=1  
%numberstyle=\tiny, %行号字体用小号  
numberstyle={\color[RGB]{0,192,192}\tiny} ,%设置行号的大小，大小有tiny,scriptsize,footnotesize,small,normalsize,large等  
numbersep=8pt,  %设置行号与代码的距离，默认是5pt  
basicstyle=\footnotesize, % 这句设置代码的大小  
showspaces=false, %  
flexiblecolumns=true, %  
breaklines=true, %对过长的代码自动换行  
breakautoindent=true,%  
breakindent=4em, %  
%escapebegin=\begin{CJK*}{GBK}{hei},escapeend=\end{CJK*},  
aboveskip=1em, %代码块边框  
tabsize=2,  
showstringspaces=false, %不显示字符串中的空格  
backgroundcolor=\color[RGB]{245,245,244},   %代码背景色  
%backgroundcolor=\color[rgb]{0.91,0.91,0.91}    %添加背景色  
escapeinside=``,  %在``里显示中文  
%% added by http://bbs.ctex.org/viewthread.php?tid=53451  
fontadjust,  
captionpos=t,  
framextopmargin=2pt,framexbottommargin=2pt,abovecaptionskip=-3pt,belowcaptionskip=3pt,  
xleftmargin=4em,xrightmargin=4em, % 设定listing左右的空白  
texcl=true,% 设定中文冲突，断行，列模式，数学环境输入，listing数字的样式  
%extendedchars=false,columns=flexible,mathescape=true  
%numbersep=-1em  
}  
\title{Java Note}
\author{徐国盛}
\begin{document}
%\begin{CJK}{UTF8}{gkai}
\maketitle
\tableofcontents
\section{Java基础}
\subsection{函数重载}
函数名一样，参数列表不一样，重载. 参数顺序不同也为重载。与函数的返回值没有任何关系
\begin{lstlisting}[language = Java]
void show (int a, char b, double c){}
a. void show(int x, char y, double z){} //because it is the same with original funciton
b. int show(int a, double c, char b){} //overload, Here are different parameter types
c. void show(int a, double c, char(b)){} //overload, it share the same reason as before
d. boolean show(int c, char b){}// overload =, because the number of parameters is different.
e. void show(double c){} //overload, the same reason as before.
f. double show(int x, char y, double z) //unoverload, it's denied in the same class
\end{lstlisting}
\subsection{数组}
\subsubsection{选择排序法和冒泡排序法}
在最后将交换位置的操作封装为一个功能。
%\input{../java/ArrayTest2.java}
\lstinputlisting[language = Java]{../java/ArrayTest2.java}

\subsubsection{数组的找key，折半查找}
折半查找一个key，前提是一个有序等的array。附加功能：对于一个有序数组，将一个元素查到该array中，并继续保证该array是有序的。
\lstinputlisting[language = Java]{../java/ArrayTest4.java}
%\end{CJK}
\subsubsection{进制转换}
在以下程序中，应用$>>>$时无符号右移，不是$>>$, 不然程序会有error。$>>$是有符号右移。在负数前面补1，正数前面补0。（这会导致成数组角标越界，因为多了一位，$--pos$会变为负数）
\lstinputlisting[language = Java]{../java/ArrayTest7.java}
\subsubsection{二维数组}
注意二维数组在内存中的存储
\lstinputlisting[language = Java]{../java/Array2Demo.java}
练习题
\lstinputlisting[language = Java]{../java/Array2Test.java}
\subsection{面向对象}

\subsubsection{成员变量和局部变量}
类类型变量指向对象

属性和行为构成了类成员。属性对应着类变量，行为对应这类中的函数。

1>作用范围

成员便来那个作用于整个类中，局部变量作用于函数中，或者语句中。

2>在内存中的位置

成员变量：在堆内存中，以为对象的存在，才在内存中存在。

局部变量：在栈内存中。

更改对象属性 对象.对象成员。


\subsubsection{匿名对象使用方式}

1>当对象的方法只调用一次时，可以用匿名对象完成，这样写比较简化。但如果对一个对象进行多个成员调用，必须给这个对象起个名字。

2>可以将匿名对象作为实际参数进行传递。但创建的对象不是垃圾。

\subsubsection{封装概述}
\textbf{封装}:对象的属性和实现细节，仅对外提供公共访问方式。
\textbf{封装原则}

\textbullet 将不需要对外提供的内容都隐藏起来。

\textbullet 把属性都隐藏，提供公共方法对其访问。
\lstinputlisting[language = Java]{../java/PersonDemo.java}
\subsubsection{构造函数}
\textbf{什么时候定义构造函数呢？}

当分析该事物时，该事物具备一些特性或者行为，那么将这些内容定义于构造函数中

\textbf{构造函数特点:}

\textbullet 函数名与类名相同

\textbullet 不定义返回值类型

\textbullet 不可以写return语句

\textbf{构造函数对象一建立就会调用与之对应的构造函数}

\textbf{构造函数的作用}：可以用于给对象进行初始化。若所有自定义构造函数被\textbf{private}关键字修饰，进行了私有化，那么对象将不能被创建。

\textbf{构造函数的小细节}：当一个类中没有定义构造函数时，那么系统会默认给该类加入一个空参数的构造函数。

当在类中自定义了构造函数后，系统就不再建立构造函数。
\lstinputlisting[language = Java]{../java/PersonDemo2.java}
\subsubsection{构造代码块}
\textbf{构造代码快作用}:给对象进行初始化。对象一建立就运行,而且优于构造函数运行。

\textbf{构造代码块与构造函数的区别}

\textbullet 构造代码块是给所有对象统一进行初始化。

\textbullet 构造函数是给对应对象进行初始化。

\textbf{将不同对象的共性初始化内容定义在构造代码块中}
\subsubsection{this关键字}
\textbf{this}关键字是用于区别局部变量和成员变量相同的情况。

\textbf{this}为什么能够解决局部变量与成员变量相同的问题？

\textbf{this}代表的是本类对象，到底代表哪一个。
\textbf{this}代表所在函数所属对象的引用。
简单说哪个对象在调用\textbf{this}所在的函数，\textbf{this}就代表哪个对象。

\textbf{this的应用}:当定义类中功能时，该函数内部要调用到该函数的对象时，这时运用\textbf{this}来表示这个对象。但凡本类功能内部使用到了本类对象，都用\textbf{this}。

\lstinputlisting[language = Java]{../java/PersonDemo3.java}

\textbf{this 与构造函数间的调用}

\textbf{this}语句：用于构造函数之间进行互相调用。

\textbf{this}语句只能定义在构造函数的第一行。因为初始化要先执行。
要注意防止死循环调用的发生。
\lstinputlisting[language = Java]{../java/PersonDemo4.java}
\subsubsection{static关键字}
\textbf{静态}：\textbf{static}
\textbf{用法}：是一个修饰符，用于修饰成员（成员变量，成员函数）。

当成源被静态修饰后，就多了一种调用方式，除了可以被对象调用外，还可以直接被
类名调用。格式是：\text{类名.静态成员}

\textbf{静态的特点}

1.随着类的加载而加载。也就是说，静态会随着类的消失而消失。说明它的生命周期最长。

2.优先于对象存在。明确一点：静态是优先存在的。对象是后存在的。

3.被所有的对象所共享。

4.可以直接被类名所调用。

\textbf{实例变量与类变量的区别}

1.存放位置
	
	类变量随着类的加载存在于方法区中。

	实例变量随着对象的建立而存在于堆内存中。

2.生命周期
	
	类变量声明周期最长，随着类的消失而消失。

	实例变量的生命周期，随着对象的消失而消失。

\textbf{静态的使用注意事项}

1.静态方法只能访问静态成员。非静态方法既可以访问静态也可以访问非静态。

2.静态方法中不可以定义\textbf{this},\textbf{super}关键字。
	
	因为静态优先于对象存在。所以静态方法中不可以出现\textbf{this}字样。

3.主函数是静态的。

\textbf{静态有利有弊}：

利处：对对象的共享数据进行单独空间的存储，节省空间的内存，没有必要每一个对象中都存储一份。

弊端：生命周期过长。

	  访问出现局限性。（静态虽好，只能访问静态。）



\lstinputlisting[language = Java]{../java/StaticDemo.java}
\subsubsection{main函数}
主函数是一个特殊的函数，作为程序的入口，可以被jvm调用。

主函数的定义：

\textit{public}：代表这该函数的访问权限是最大的。

\textit{static}：代表这主函数随着类的加载就已经存在了。

\textit{void}：主函数没有具体的返回值。

\textit{main}：不是关键字，但是一个特殊的单词，可以被jvm识别。

(String[] args):函数的参数，参数类型是一个数组，该数组中的元素是字符串。也可以称作字符串类型的数组。

主函数的固定格式：jvm识别。
jvm在调用主函数时，传入的是new String[0];
\lstinputlisting[language = Java]{../java/MainDemo.java}
\subsubsection{静态的使用}
什么时候使用静态？

要从两方面下手：

因为静态修饰的内容有成员变量和函数。

什么时候定义静态变量（类变量）呢？

当对象中出现共享数据时，该数据被静态所修饰。
对象中的特有数据要定义成非静态寻在于堆内存中。

什么时候定义静态函数呢？

当功能内部没有访问到非静态数据(对象的特有数据)，那么该功能可以定义成静态的。

\textbf{一个静态应用的例子}
\lstinputlisting[language = Java]{../java/ArrayTool.java}
\lstinputlisting[language = Java]{../java/ArrayToolDemo.java}

设置class文件按路径

\textit{set classpath=.;c\\:\\myclass}
\subsubsection{生成说明文档}

\textit{javadoc -d ~/Document/java -author -version ArrayTool.java}
\subsubsection{静态代码块}

静态代码块特点:随着类的加载而执行，只执行一次，并且只执行一次，优先于主函数执行。

用于给类进行初始化的。

运行优先顺序：静态代码块~$\geq$~ 构造代码块~$\geq$~ 构造函数
\lstinputlisting[language = Java]{../java/StaticCodeDemo.java} 
\subsubsection{对象初始化过程}

\textbullet 因为new用到了Person.class，所以会先找到Person.class文件并加载到内存中。

\textbullet 执行该类中的static代码块，如果有的话，给Person.class类进行初始化。

\textbullet 在堆内存中开辟空间，分配内存地址。

\textbullet 在堆内存中建立对象的特有属性，并进行默认初始化。

\textbullet 对属性进行显示初始化。

\textbullet 对对象进行构造代码块初始化。

\textbullet 对对象进行对应的构造函数初始化。

\textbullet 将内存地址付给栈内存中的p变量。

对象初始化过程如下图所示：
\begin{figure}[ht]
\centering
\includegraphics[width = 12cm]{../Dia/duixiang_chushi.jpeg}
\caption{对象初始化过程}
\end{figure}

\lstinputlisting[language = Java]{../java/PersonDemo.java}
\subsubsection{对象调用成员过程}
\begin{figure}[ht]
\centering
\includegraphics[width = 12cm]{../Dia/duixiang_dycy.jpeg}
\caption{对象成员调用过程}
\end{figure}
\subsubsection{单例设计模式}

单例设计模式：解决一个类在内存只存在一个对象。

想要保证对象唯一。
\textbullet 为了避免其他程序过多的建立该类对象，先禁止其他程序建立该类对象。

\textbullet 还为了让其他程序可以访问到该类对象，只好在本类中，自定义一个对象。

\textbullet 为了方便其他程序对自定义对象的访问，可以对外提供一些访问的方式。

这三步怎样用代码代替
\textbullet 将构造函数私有化。

\textbullet 在类中创建一个本类对象。

\textbullet 提供一个方法可以获取到该对象。

对于单例模式的内存运作过程如下图：
\begin{figure}[ht]
\centering
\includegraphics[width = 12cm]{../Dia/SingleDemo.jpeg}
\caption{单例模式的内存运作过程}
\end{figure}
\lstinputlisting[language = Java]{../java/SingleDemo.java}
\subsubsection{单例设计模式2}

饿汉式：就是上一节提到的，先初始化对象。

懒汉式：对象方法被调用时，才初始化，也叫做对象的延时加载。

\textbf{开发时，定义单例，建议使用饿汉式}。
\lstinputlisting[language = Java]{../java/SingleDemo2.java}
\subsubsection{继承概述}
\textbf{继承}：

1.提高代码的复用性。

2.让类与类之间产生了关系，有了这个关系，才有了多台的特性。

\textbf{注意}：千万不要为了获取其他类的功能，简化代码而继承，必须是类与类之间有所属关系才可以继承。

Java语言中：Java只支持单继承，不支持多继承。

因为多继承容易带来安全隐患：当父类中定义了相同的功能，当功能内容不同时，不确定要运行哪一个。但是Java保留了这种机制。并用另一种体现形式来完成表示，就是多实现。

java支持多层继承。也就是一个继承体系。如何使用一个继承体系中的功能呢？

想要使用继承体系，先查阅体系中父类的描述。因为父类中定义了该体系中的共性功能。通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了。

在具体调用时，要创建最子类对象。因为有可能父类不能创建对象，二是创建子类对象可以使用更多的功能包括基本的也包括特有的。

简单一句话：查阅父类功能，创建子类对象使用功能。
\lstinputlisting[language = Java]{../java/ExtendsDemo.java}
\subsubsection{子父类中变量、函数和构造函数的特点}

子父类出现后，类成员的特点：

类中成员

\textbullet 变量

\textbullet 函数

\textbullet 构造函数

1.变量

如果子父类中出现了非私有的同名成员变量时，子类要访问本类中的变量用this，
子类要访问父类中的同名变量，用super。

\textbullet super的使用和this几乎一致。this代表的是本类对象的引用。super代表的是父类对象的引用。

2.子父类中的函数（覆盖：重写）

当子类出现和父类一模一样的函数时，当子类对象调用该函数，会运行子类函数的内容。如同父类函数被覆盖一样。这种情况时函数的另一个特性：重写（覆盖）。

当子类继承父类，沿袭了父类的功能到子类中，子类虽具有该功能，但是功能的内容却和父类不一致，这是，没有必要定义新功能，而是使用覆盖特性，保留父类的功能定义，并重写功能内容。

覆盖：

\textbullet 子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖。

\textbullet 静态只能覆盖静态。

\textbf{记住}：

重载：只看同名函数的参数列表

重写：子类父类方法要一模一样，包括返回值类型。
\lstinputlisting[language = Java]{../java/ExtendsDemo2.java}

3.子父类中的构造函数

在对子类对象进行初始化时，父类的构造函数也会运行。
那是因为子类的构造函数默认第一行有一条隐式的语句 super();
super();回访父类中空参数的构造函数，而且子类中所有的构造函数第一行都是super();

为什么子类一定要回访父类中的构造函数。

因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要查看父类是如何对这些数据进行初始化的。

所以子类在对象初始化时，要先访问以下父类中的构造函数。如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。

\textbf{注意：}super语句一定定义在子类构造函数的第一行。

以上过程也叫做子类的实例化过程。

\textbf{结论}

\textbullet 子类的所有构造函数，默认都会访问父类中空参数的构造函数。

\textbullet 因为子类每一个构造函数的第一行都有一句隐式的super();

\textbullet 当父类中没有空参数的构造函数时，子类必须手动通过super或this语句的形式来指定要访问父类中的构造函数。

当然：子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数。

this super 不能同时在构造函数中，因为不能同时在第一行，因为初始化动作要先做。

\lstinputlisting[language = Java]{../java/ExtendsDemo4.java}
\subsubsection{final关键字}
final：最终。作为一个修饰符。

\textbullet 可以修饰类，变量，函数。

\textbullet 被final修饰的类不可以被继承。为了避免被继承，避免被子类复写功能。

\textbullet 被final修饰的变量是一个常量，只能赋值一次，既可以修饰成员变量，又可以修饰局部变量。

挡在描述事物时，一些数据的出现是固定的，那么这时为了增强阅读性，都给着这些值起个名字，方便于阅读。而这个值不需要改变，所以加上final修饰.作为常量：常量的书写规范所有字母都大写,如果由多个单词组成,单词通过\_连接。

\textbullet 内部类定义在类中的局部位置上时，只能访问该局部被fianl修饰的局部变量。
\lstinputlisting[language = Java]{../java/FinalDemo.java}
\end{document}
