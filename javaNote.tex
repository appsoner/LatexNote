\documentclass[UTF8]{ctexart}
%\usepackage{CJKutf8}
\setCJKmainfont{KaiTi}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[%dvipdfm,  %pdflatex,pdftex这里决定运行文件的方式不同
pdfstartview=FitH,
CJKbookmarks=true,
bookmarksnumbered=true,
bookmarksopen=true,
colorlinks, %注释掉此项则交叉引用为彩色边框(将colorlinks和pdfborder同时注释掉)
pdfborder=001,   %注释掉此项则交叉引用为彩色边框
linkcolor=green,
anchorcolor=green,
citecolor=green
]{hyperref}  
\lstset{%  
alsolanguage=Java,  
%language={[ISO]C++},       %language为，还有{[Visual]C++}  
%alsolanguage=[ANSI]C,      %可以添加很多个alsolanguage,如alsolanguage=matlab,alsolanguage=VHDL等  
%alsolanguage= tcl,  
alsolanguage= XML,  
tabsize=4, %  
frame=shadowbox, %把代码用带有阴影的框圈起来  
commentstyle=\color{red!60!blue!90},%浅灰色的注释  
rulesepcolor=\color{red!20!green!20!blue!20},%代码块边框为淡青色  
keywordstyle=\color{blue!90}\bfseries, %代码关键字的颜色为蓝色，粗体  
showstringspaces=false,%不显示代码字符串中间的空格标记  
stringstyle=\ttfamily, % 代码字符串的特殊格式  
keepspaces=true, %  
breakindent=22pt, %  
numbers=left,%左侧显示行号 往左靠,还可以为right，或none，即不加行号  
stepnumber=1,%若设置为2，则显示行号为1,3,5，即stepnumber为公差,默认stepnumber=1  
%numberstyle=\tiny, %行号字体用小号  
numberstyle={\color[RGB]{0,192,192}\tiny} ,%设置行号的大小，大小有tiny,scriptsize,footnotesize,small,normalsize,large等  
numbersep=8pt,  %设置行号与代码的距离，默认是5pt  
basicstyle=\footnotesize, % 这句设置代码的大小  
showspaces=false, %  
flexiblecolumns=true, %  
breaklines=true, %对过长的代码自动换行  
breakautoindent=true,%  
breakindent=4em, %  
%escapebegin=\begin{CJK*}{GBK}{hei},escapeend=\end{CJK*},  
aboveskip=1em, %代码块边框  
tabsize=2,  
showstringspaces=false, %不显示字符串中的空格  
backgroundcolor=\color[RGB]{245,245,244},   %代码背景色  
%backgroundcolor=\color[rgb]{0.91,0.91,0.91}    %添加背景色  
escapeinside=``,  %在``里显示中文  
%% added by http://bbs.ctex.org/viewthread.php?tid=53451  
fontadjust,  
captionpos=t,  
framextopmargin=2pt,framexbottommargin=2pt,abovecaptionskip=-3pt,belowcaptionskip=3pt,  
xleftmargin=4em,xrightmargin=4em, % 设定listing左右的空白  
texcl=true,% 设定中文冲突，断行，列模式，数学环境输入，listing数字的样式  
%extendedchars=false,columns=flexible,mathescape=true  
%numbersep=-1em  
}  
\title{Java Note}
\author{徐国盛}
\begin{document}
%\begin{CJK}{UTF8}{gkai}
\maketitle
\tableofcontents
\section{Java基础}
\subsection{函数重载}
函数名一样，参数列表不一样，重载. 参数顺序不同也为重载。与函数的返回值没有任何关系
\begin{lstlisting}[language = Java]
void show (int a, char b, double c){}
a. void show(int x, char y, double z){} //because it is the same with original funciton
b. int show(int a, double c, char b){} //overload, Here are different parameter types
c. void show(int a, double c, char(b)){} //overload, it share the same reason as before
d. boolean show(int c, char b){}// overload =, because the number of parameters is different.
e. void show(double c){} //overload, the same reason as before.
f. double show(int x, char y, double z) //unoverload, it's denied in the same class
\end{lstlisting}
\subsection{数组}
\subsubsection{选择排序法和冒泡排序法}
在最后将交换位置的操作封装为一个功能。
%\input{../java/ArrayTest2.java}
\lstinputlisting[language = Java]{../java/ArrayTest2.java}

\subsubsection{数组的找key，折半查找}
折半查找一个key，前提是一个有序等的array。附加功能：对于一个有序数组，将一个元素查到该array中，并继续保证该array是有序的。
\lstinputlisting[language = Java]{../java/ArrayTest4.java}
%\end{CJK}
\subsubsection{进制转换}
在以下程序中，应用$>>>$时无符号右移，不是$>>$, 不然程序会有error。$>>$是有符号右移。在负数前面补1，正数前面补0。（这会导致成数组角标越界，因为多了一位，$--pos$会变为负数）
\lstinputlisting[language = Java]{../java/ArrayTest7.java}
\subsubsection{二维数组}
注意二维数组在内存中的存储
\lstinputlisting[language = Java]{../java/Array2Demo.java}
练习题
\lstinputlisting[language = Java]{../java/Array2Test.java}
\subsection{面向对象}

\subsubsection{成员变量和局部变量}
类类型变量指向对象

属性和行为构成了类成员。属性对应着类变量，行为对应这类中的函数。

1>作用范围

成员便来那个作用于整个类中，局部变量作用于函数中，或者语句中。

2>在内存中的位置

成员变量：在堆内存中，以为对象的存在，才在内存中存在。

局部变量：在栈内存中。

更改对象属性 对象.对象成员。


\subsubsection{匿名对象使用方式}

1>当对象的方法只调用一次时，可以用匿名对象完成，这样写比较简化。但如果对一个对象进行多个成员调用，必须给这个对象起个名字。

2>可以将匿名对象作为实际参数进行传递。但创建的对象不是垃圾。

\subsubsection{封装概述}
\textbf{封装}:对象的属性和实现细节，仅对外提供公共访问方式。
\textbf{封装原则}

\textbullet 将不需要对外提供的内容都隐藏起来。

\textbullet 把属性都隐藏，提供公共方法对其访问。
\lstinputlisting[language = Java]{../java/PersonDemo.java}
\subsubsection{构造函数}
\textbf{什么时候定义构造函数呢？}

当分析该事物时，该事物具备一些特性或者行为，那么将这些内容定义于构造函数中

\textbf{构造函数特点:}

\textbullet 函数名与类名相同

\textbullet 不定义返回值类型

\textbullet 不可以写return语句

\textbf{构造函数对象一建立就会调用与之对应的构造函数}

\textbf{构造函数的作用}：可以用于给对象进行初始化。若所有自定义构造函数被\textbf{private}关键字修饰，进行了私有化，那么对象将不能被创建。

\textbf{构造函数的小细节}：当一个类中没有定义构造函数时，那么系统会默认给该类加入一个空参数的构造函数。

当在类中自定义了构造函数后，系统就不再建立构造函数。
\lstinputlisting[language = Java]{../java/PersonDemo2.java}
\subsubsection{构造代码块}
\textbf{构造代码快作用}:给对象进行初始化。对象一建立就运行,而且优于构造函数运行。

\textbf{构造代码块与构造函数的区别}

\textbullet 构造代码块是给所有对象统一进行初始化。

\textbullet 构造函数是给对应对象进行初始化。

\textbf{将不同对象的共性初始化内容定义在构造代码块中}
\subsubsection{this关键字}
\textbf{this}关键字是用于区别局部变量和成员变量相同的情况。

\textbf{this}为什么能够解决局部变量与成员变量相同的问题？

\textbf{this}代表的是本类对象，到底代表哪一个。
\textbf{this}代表所在函数所属对象的引用。
简单说哪个对象在调用\textbf{this}所在的函数，\textbf{this}就代表哪个对象。

\textbf{this的应用}:当定义类中功能时，该函数内部要调用到该函数的对象时，这时运用\textbf{this}来表示这个对象。但凡本类功能内部使用到了本类对象，都用\textbf{this}。

\lstinputlisting[language = Java]{../java/PersonDemo3.java}

\textbf{this 与构造函数间的调用}

\textbf{this}语句：用于构造函数之间进行互相调用。

\textbf{this}语句只能定义在构造函数的第一行。因为初始化要先执行。
要注意防止死循环调用的发生。
\lstinputlisting[language = Java]{../java/PersonDemo4.java}
\subsubsection{static关键字}
\textbf{静态}：\textbf{static}
\textbf{用法}：是一个修饰符，用于修饰成员（成员变量，成员函数）。

当成源被静态修饰后，就多了一种调用方式，除了可以被对象调用外，还可以直接被
类名调用。格式是：\text{类名.静态成员}

\textbf{静态的特点}

1.随着类的加载而加载。也就是说，静态会随着类的消失而消失。说明它的生命周期最长。

2.优先于对象存在。明确一点：静态是优先存在的。对象是后存在的。

3.被所有的对象所共享。

4.可以直接被类名所调用。

\textbf{实例变量与类变量的区别}

1.存放位置
	
	类变量随着类的加载存在于方法区中。

	实例变量随着对象的建立而存在于堆内存中。

2.生命周期
	
	类变量声明周期最长，随着类的消失而消失。

	实例变量的生命周期，随着对象的消失而消失。

\textbf{静态的使用注意事项}

1.静态方法只能访问静态成员。非静态方法既可以访问静态也可以访问非静态。

2.静态方法中不可以定义\textbf{this},\textbf{super}关键字。
	
	因为静态优先于对象存在。所以静态方法中不可以出现\textbf{this}字样。

3.主函数是静态的。

\textbf{静态有利有弊}：

利处：对对象的共享数据进行单独空间的存储，节省空间的内存，没有必要每一个对象中都存储一份。

弊端：生命周期过长。

	  访问出现局限性。（静态虽好，只能访问静态。）



\lstinputlisting[language = Java]{../java/StaticDemo.java}
\subsubsection{main函数}
主函数是一个特殊的函数，作为程序的入口，可以被jvm调用。

主函数的定义：

\textit{public}：代表这该函数的访问权限是最大的。

\textit{static}：代表这主函数随着类的加载就已经存在了。

\textit{void}：主函数没有具体的返回值。

\textit{main}：不是关键字，但是一个特殊的单词，可以被jvm识别。

(String[] args):函数的参数，参数类型是一个数组，该数组中的元素是字符串。也可以称作字符串类型的数组。

主函数的固定格式：jvm识别。
jvm在调用主函数时，传入的是new String[0];
\lstinputlisting[language = Java]{../java/MainDemo.java}
\subsubsection{静态的使用}
什么时候使用静态？

要从两方面下手：

因为静态修饰的内容有成员变量和函数。

什么时候定义静态变量（类变量）呢？

当对象中出现共享数据时，该数据被静态所修饰。
对象中的特有数据要定义成非静态寻在于堆内存中。

什么时候定义静态函数呢？

当功能内部没有访问到非静态数据(对象的特有数据)，那么该功能可以定义成静态的。

\textbf{一个静态应用的例子}
\lstinputlisting[language = Java]{../java/ArrayTool.java}
\lstinputlisting[language = Java]{../java/ArrayToolDemo.java}

设置class文件按路径

\textit{set classpath=.;c\\:\\myclass}
\subsubsection{生成说明文档}

\textit{javadoc -d ~/Document/java -author -version ArrayTool.java}
\subsubsection{静态代码块}

静态代码块特点:随着类的加载而执行，只执行一次，并且只执行一次，优先于主函数执行。

用于给类进行初始化的。

运行优先顺序：静态代码块~$\geq$~ 构造代码块~$\geq$~ 构造函数
\lstinputlisting[language = Java]{../java/StaticCodeDemo.java} 
\subsubsection{对象初始化过程}

\textbullet 因为new用到了Person.class，所以会先找到Person.class文件并加载到内存中。

\textbullet 执行该类中的static代码块，如果有的话，给Person.class类进行初始化。

\textbullet 在堆内存中开辟空间，分配内存地址。

\textbullet 在堆内存中建立对象的特有属性，并进行默认初始化。

\textbullet 对属性进行显示初始化。

\textbullet 对对象进行构造代码块初始化。

\textbullet 对对象进行对应的构造函数初始化。

\textbullet 将内存地址付给栈内存中的p变量。

对象初始化过程如下图所示：
\begin{figure}[ht]
\centering
\includegraphics[width = 12cm]{../Dia/duixiang_chushi.jpeg}
\caption{对象初始化过程}
\end{figure}

\lstinputlisting[language = Java]{../java/PersonDemo.java}
\subsubsection{对象调用成员过程}
\begin{figure}[ht]
\centering
\includegraphics[width = 12cm]{../Dia/duixiang_dycy.jpeg}
\caption{对象成员调用过程}
\end{figure}
\subsubsection{单例设计模式}

单例设计模式：解决一个类在内存只存在一个对象。

想要保证对象唯一。
\textbullet 为了避免其他程序过多的建立该类对象，先禁止其他程序建立该类对象。

\textbullet 还为了让其他程序可以访问到该类对象，只好在本类中，自定义一个对象。

\textbullet 为了方便其他程序对自定义对象的访问，可以对外提供一些访问的方式。

这三步怎样用代码代替
\textbullet 将构造函数私有化。

\textbullet 在类中创建一个本类对象。

\textbullet 提供一个方法可以获取到该对象。

对于单例模式的内存运作过程如下图：
\begin{figure}[ht]
\centering
\includegraphics[width = 12cm]{../Dia/SingleDemo.jpeg}
\caption{单例模式的内存运作过程}
\end{figure}
\lstinputlisting[language = Java]{../java/SingleDemo.java}
\subsubsection{单例设计模式2}

饿汉式：就是上一节提到的，先初始化对象。

懒汉式：对象方法被调用时，才初始化，也叫做对象的延时加载。

\textbf{开发时，定义单例，建议使用饿汉式}。
\lstinputlisting[language = Java]{../java/SingleDemo2.java}
\subsubsection{继承概述}
\textbf{继承}：

1.提高代码的复用性。

2.让类与类之间产生了关系，有了这个关系，才有了多台的特性。

\textbf{注意}：千万不要为了获取其他类的功能，简化代码而继承，必须是类与类之间有所属关系才可以继承。

Java语言中：Java只支持单继承，不支持多继承。

因为多继承容易带来安全隐患：当父类中定义了相同的功能，当功能内容不同时，不确定要运行哪一个。但是Java保留了这种机制。并用另一种体现形式来完成表示，就是多实现。

java支持多层继承。也就是一个继承体系。如何使用一个继承体系中的功能呢？

想要使用继承体系，先查阅体系中父类的描述。因为父类中定义了该体系中的共性功能。通过了解共性功能，就可以知道该体系的基本功能。那么这个体系已经可以基本使用了。

在具体调用时，要创建最子类对象。因为有可能父类不能创建对象，二是创建子类对象可以使用更多的功能包括基本的也包括特有的。

简单一句话：查阅父类功能，创建子类对象使用功能。
\lstinputlisting[language = Java]{../java/ExtendsDemo.java}
\subsubsection{子父类中变量、函数和构造函数的特点}

子父类出现后，类成员的特点：

类中成员

\textbullet 变量

\textbullet 函数

\textbullet 构造函数

1.变量

如果子父类中出现了非私有的同名成员变量时，子类要访问本类中的变量用this，
子类要访问父类中的同名变量，用super。

\textbullet super的使用和this几乎一致。this代表的是本类对象的引用。super代表的是父类对象的引用。

2.子父类中的函数（覆盖：重写）

当子类出现和父类一模一样的函数时，当子类对象调用该函数，会运行子类函数的内容。如同父类函数被覆盖一样。这种情况时函数的另一个特性：重写（覆盖）。

当子类继承父类，沿袭了父类的功能到子类中，子类虽具有该功能，但是功能的内容却和父类不一致，这是，没有必要定义新功能，而是使用覆盖特性，保留父类的功能定义，并重写功能内容。

覆盖：

\textbullet 子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖。

\textbullet 静态只能覆盖静态。

\textbf{记住}：

重载：只看同名函数的参数列表

重写：子类父类方法要一模一样，包括返回值类型。
\lstinputlisting[language = Java]{../java/ExtendsDemo2.java}

3.子父类中的构造函数

在对子类对象进行初始化时，父类的构造函数也会运行。
那是因为子类的构造函数默认第一行有一条隐式的语句 super();
super();回访父类中空参数的构造函数，而且子类中所有的构造函数第一行都是super();

为什么子类一定要回访父类中的构造函数。

因为父类中的数据子类可以直接获取，所以子类对象在建立时，需要查看父类是如何对这些数据进行初始化的。

所以子类在对象初始化时，要先访问以下父类中的构造函数。如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。

\textbf{注意：}super语句一定定义在子类构造函数的第一行。

以上过程也叫做子类的实例化过程。

\textbf{结论}

\textbullet 子类的所有构造函数，默认都会访问父类中空参数的构造函数。

\textbullet 因为子类每一个构造函数的第一行都有一句隐式的super();

\textbullet 当父类中没有空参数的构造函数时，子类必须手动通过super或this语句的形式来指定要访问父类中的构造函数。

当然：子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数，子类中至少会有一个构造函数会访问父类中的构造函数。

this super 不能同时在构造函数中，因为不能同时在第一行，因为初始化动作要先做。

\lstinputlisting[language = Java]{../java/ExtendsDemo4.java}
\subsubsection{final关键字}
final：最终。作为一个修饰符。

\textbullet 可以修饰类，变量，函数。

\textbullet 被final修饰的类不可以被继承。为了避免被继承，避免被子类复写功能。

\textbullet 被final修饰的变量是一个常量，只能赋值一次，既可以修饰成员变量，又可以修饰局部变量。

挡在描述事物时，一些数据的出现是固定的，那么这时为了增强阅读性，都给着这些值起个名字，方便于阅读。而这个值不需要改变，所以加上final修饰.作为常量：常量的书写规范所有字母都大写,如果由多个单词组成,单词通过\_连接。

\textbullet 内部类定义在类中的局部位置上时，只能访问该局部被fianl修饰的局部变量。
\lstinputlisting[language = Java]{../java/FinalDemo.java}
\subsubsection{抽象类}

当多个类出现相同功能，但是功能主体不同，这是可以进行向上抽取。这时，只抽取功能定义，而不抽取功能主体。

抽象：看不懂的意思。

抽象的特点：

\textbullet 抽象方法一定定义在抽象类中。

\textbullet 抽象方法和抽象类都必须被abstract关键字修饰。

\textbullet 抽象类不可以用new创建对象。因为调用抽象方法没有意义。

\textbullet 抽象类中的抽象方法要被使用，必须由子类复写其所有的抽象方法后，建立对象调用。

\textbf{如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。}

抽象类和一般类没有太大的不同。该类如何描述事物就如何描述事物，只不过该事物出现了一些看不懂的东西。这些不确定的部分也是该事物的功能，需要明确出来，但是无法定义主体。通过抽象方法来表示。

抽象类比一般类多了抽象函数。就是在类中可以定义抽象方法。

\textbf{抽象类不可以实例化。}

\textbf{特殊：}抽象类中可以不定义抽象方法,这样做仅仅是不让该类建立对象。
\lstinputlisting[language = Java]{../java/AbstractDemo.java}

一个抽象类的练习
\lstinputlisting[language = Java] {../java/AbstractTest.java}

\subsubsection{模板方法模式}

需求：获取一段程序运行时间。

原理：获取程序开始和结束事件相减即可

获取时间：System.currectTimeMillis();

当代码完成优化后，就可以解决这类问题。

这种方式为模板方法设计模式。

什么是模板方法？

在定义功能时，功能的一部分是确定的，但有一部分是不确定的，而确定的部分使用不确定的部分，那么这时就将不确定的部分暴露出去，又该类的子类去完成。	

\lstinputlisting[language = Java]{../java/TemplateDemo.java}
\subsubsection{接口}

接口：初期理解，可以认为一个特殊的抽象类。当类中的方法都是抽象的，该类可以通过接口的形式来表示。

class 用于定义类。

interface 用于定义接口。

接口在定义时，格式特点在于：

1.接口中常见的定义:常量，抽象方法。

2.接口中的成员都有固定的修饰符。

\quad \textbullet 常量：public static final

\quad \textbullet 方法：public abstract

\textbf{记住：}接口中的成员都是public的。

接口：是不可以创建对象的.因为有抽象方法。需要被子类实现，子类对接口中的抽象
方法全部覆盖后，子类才可以实例化。否则子类是一个抽象类。

接口可以被类多实现，也是对多继承不支持的转换形式，Java支持多实现。

接口与接口之间支持继承，多继承。

接口的特点:

\textbullet 接口是对外暴露的规则。

\textbullet 接口时程序的功能扩展。降低了耦合性。

\textbullet 接口可以用来多实现。

\textbullet 类与接口的关系是实现关系，而且类可以继承一个类的同时实现多个接口。

\textbullet 接口于接口之间可以有继承关系，也可以有多继承关系。

\lstinputlisting[language = Java]{../java/InterfaceDemo.java}
接口的举例实现。类时is a。是确定有的，接口时like a。时可能有的。当具有接口的功能时，就实现接口。

\lstinputlisting[language = Java]{../java/InterfaceTest.java}
\subsubsection{多态}

\textbullet \textbf{多态的概念}
	
多态：可以理解为事物存在的多种体现形态。

人：男人，女人
动物：猫，狗

猫 x = new 猫();
动物 x = new 猫();

\textbullet \textbf{多态的基本体现}
	
\quad 父类的引用指向自己的子类对象。

\quad 父类的引用也可以接受自己的子类对象。

\textbullet \textbf{多态的前提}

\quad 必须是类与类之间有关系，要么继承，要么实现。通常还得有一个前提：存在覆盖。

\textbullet \textbf{多态的好处}

\quad 多态的出现大大提高了程序的扩展性。

\textbullet \textbf{多态的弊端}

\quad 提高了扩展性，但是只能使用父类的引用访问父类中的成员。

\textbullet 多态的应用

\textbullet \textbf{多态出现代码中的特点(多态使用的注意事项)}
\lstinputlisting[language = Java]{../java/DuoTaiDemo.java}

多态可以同时操作很多对象。建立一个工具类，具有共同的属性，多态产生同一个大类型，通过对大类型的引用，可以操作多个小类型。因此，提高了扩展性。
\lstinputlisting[language = Java]{../java/DuoTaiDemo3.java}

\textbullet \textbf{多态成员中非静态函数的特点：}

\quad 在编译时期：参阅引用型变量所属的类中是否有调用方法。如果有，编译通过，否则，编译失败；

\quad 在运行时期：参阅对象所属的类中是否有调用的方法。

\quad 简单总结就是：成员函数在多态调用时，编译看左边,运行看右边。

\textbullet \textbf{多态中，成员变量的特点：}

\quad 无论编译和运行，都参考左边（引用型变量所属的类）。

\textbullet \textbf{多态中，静态成员函数的特点：}

\quad 无论编译和运行，都参考左边（引用型变量所属的类）。
\lstinputlisting[language = Java]{../java/DuoTaiDemo4.java}

\textbf{实例}
\lstinputlisting[language = Java]{../java/DuoTaiDemo5.java}
\lstinputlisting[language = Java]{../java/DBOperate.java}
\subsubsection{Object类}

Object:是所有对象的直接或者间接父类。该类中定义的肯定是所有对象都具备的功能。

Object类中已经提供了对对象是否相同的比较方法。

如果自定义类中也有比较相同的功能，没有必要重新定义。只要沿袭父类的功能，建立自己特有的比较内容，这就是覆盖。
\lstinputlisting[language = Java]{../java/ObjectDemo.java}
\subsubsection{内部类}

\textbf{内部类的访问规则}

\textbullet 内部类可以直接访问外部类中的成员，包括私有private。之所以可以直接访问外部类中的成员，是因为内部类中持有了一个外部类的引用，格式：外部类名.this

\textbullet 内部类可以被私有private修饰（成员位置上）

\textbf{访问格式：}

\textbullet 当定义内部类在外部类的成员位置上时，而且非私有，可以在外部其他类中，直接建立内部对象。

格式：外部类名.内部类名 变量名 = 外部类对象.内部类对象;

\qquad Outer.Inner in = new Outer().new Inner();

\textbullet 当内部类在成员位置上，就可以被成员修饰符所修饰。比如：

private:将内部类在外部类中进行封装。

static:内部类就具备static特性。当内部类被static修饰后，只能访问外部类中的static成员。出现了访问局限。

当其他外部类中，如何直接访问static类中的非静态成员呢？

new Outer.Inner().function();

在其他外部类中，如何直接访问static类中的静态成员呢？

new Outer.Inner.function();

注意：当内部类中定义了静态成员，该类必须是静态的。

	当外部类中的静态方法访问内部类时，内部类也必须是static的。

当描述事物时，事物的内容中还有事物，该事物用内部类来描述。因为内部事物在使用外部事物的内容。
\lstinputlisting[language = Java]{../java/InnerClassDemo.java}

\textbf{内部类被定义在局部时}

\textbullet 不可以被成员修饰符修饰。局部内部类不能被静态和私有修饰。

\textbullet 可以访问外部类中的成员，因为还持有外部类的引用。但是不可以访问它所在局部中的变量，只能访问被final修饰的局部变量。	
\lstinputlisting[language = Java]{../java/InnerClassDemo3.java}
\subsubsection{匿名内部类}

\textbullet 匿名内部类其实就是内部类的简写格式。

\textbullet 定义内部类的前提：内部类必须继承一个类或者实现接口。

\textbullet 匿名内部类的格式：new 父类或者接口(){定义子类的内容}

\textbullet 其实匿名内部类就是一个匿名子对象。而且这个对象有点胖，可以理解为带内容的对象。

\textbullet 匿名内部类中定义的方法最好不要超过3个。

\lstinputlisting[language = Java]{../java/InnerClassDemo4.java}

\textbf{实例}
\lstinputlisting[language = Java]{../java/InnerClassTest.java}
\subsection{异常}
\subsubsection{异常的概述}

异常：就是程序在运行时出现的不正常情况。

异常由来：问题也是现实生活中一个具体的事物，也可以通过java的形式进行描述，并封装成对象。其实就是java对不正常的情况进行描述的对象体现。

对于问题的划分：两种：一种时严重的问题，一种是非严重的问题。

\textbullet 对于严重的，java通过Error类进行描述。

\qquad 对于Error一般不编写针对性的代码对其进行处理。

\textbullet 对于非严重的，java通过Exception类进行描述。

\qquad 对于Exception可以使用针对性的处理方式进行处理。

无论Error或者Exception都有一些共性内容。比如：不正常情况的信息，引发原因等。

\textit{Throwable}

\qquad |--\textit{Error}

\qquad |--\textit{Exception}
\subsubsection{异常的处理}

\textbullet java提供了特有的语句进行处理。

try\{

\qquad 需要被检测的代码

\}

catch (异常类 变量)\{

\qquad 处理异常的代码;(处理方式)

\}

finally \{

\qquad 一定会执行的语句

\}

\textbullet 对捕获的异常对象进行常见方法操作。

\qquad String getMessage();获取异常信息。

函数上声明异常。

便于提高安全性，让调用处进行处理。不处理编译失败。

对多异常的处理。

\textbullet 声明异常时，建议声明更为具体的异常，这样处理的可以更具体。

\textbullet 对方声明有几个异常，就对应有几个catch块，不要定以多余的catch块。
如果多个catch块中的异常出现继承关系，父类异常catch放在最下面。

建议在进行catch处理时，catch中一定要定义成具体处理方式。不要简单的定义一句 e.printStackTrace(),也不要简单的就书写一条输出语句。
\lstinputlisting[language = Java]{../java/ExceptionDemo.java}

\subsubsection{自定义异常}

因为项目中会出现特有的问题，而这些问题并为被java描述，并封装对象。所以对于这些特有的问题可以按照java对问题封装的思想，将问题进行自定义的异常封装。

自定义异常。

需求：在本程序中，对于除数是负数，也视为是错误的是无法进行运算的。那么就需要对这个问题进行自定义描述。

当在函数内部出现了throw抛出异常对象，那么就必须给出对应的处理动作。要么在内部try，catch处理。要么在函数上声明调用这处理。

一般情况下，函数内出现异常，函数上需要声明。

发现打印的结果只有异常的名称，却没有异常的信息。因为自定义的异常并未定义信息。

如何定义异常信息呢？

因为父类中已经把异常信息的操作都完成了。所以子类只要在构造时，将异常信息传递个父类通过super语句。

\textbf{自定义异常：}必须是自定义类继承Exception。

继承Exception的原因：异常体系有一个特点：因为异常类和异常对象都需要被抛出。他们都具有可抛性。这个可抛性时Throwable这个体系中的多有特点。

只有这个体系中的类和对象才可以被throws和throw操作。

throws和throw的区别：

\textbullet throws 使用在函数上；throw 使用在函数内。

\textbullet throws 后面跟的是异常类，可以跟多个。用逗号隔开；throw后面跟的是异常对象。

\lstinputlisting[language = Java]{../java/ExceptionDemo3.java}

\subsubsection{RuntimeException异常}

Exception中有一个特殊的子类异常RuntimeException运行时异常。

如果在函数内容抛出该异常，函数上可以声明，编译一样通过。

如果在函数上声明改异常，调用者可以不用进行处理。编译一样通过。

之所以不再函数上声明，是因为不需要让调用者处理。该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，由程序员对代码进行修正。

自定义异常时：如果该异常的发生，无法继续进行运算，就让自定义异常继承RuntimeException。

对异常分两种：

1.编译时被检测的异常。

2.编译时不被检测的异常。（运行时异常。RuntimeException以及其子类）。
\lstinputlisting[language = Java]{../java/ExceptionDemo4.java}
\subsubsection{finally代码块}

finally代码块：定义一定执行的代码。通常用于关闭资源。	
\lstinputlisting[language = Java]{../java/ExceptionDemo5.java}

\subsubsection{处理语句的其他格式}

问题被解决，可以不用声明。有catch就是问题解决。没有catch就是没有处理。

记住一点：catch是用于处理异常的。如果没有catch就代表没有被处理，如果该异常是检测性异常，那么必须声明

\textbullet 第一个格式

\textit{try} \{
		
	
	
	\}

\textit{catch} \{
	


	\}

\textbullet 第二种格式

\textit{try}\{

\}

\textit{catch}()\{

\}

\textit{finally}\{

\}

\textbullet 第三种格式

\textit{try} \{

\}

\textit{finally} \{

\}
\lstinputlisting[language = Java]{../java/ExceptionDemo6.java}

\subsubsection{覆盖时的异常特点}

异常在子类覆盖中的体现。

\textbullet 子类在覆盖父类时，如果父类的方法抛出异常,那么子类的覆盖方法，只能抛出父类的异常或该异常的子类，或者不抛。

\textbullet 如果父类的方法抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集。

\textbullet 如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时也不可以抛出异常。如果子类方法发生了异常就必须进行try处理，绝对不能抛。

\lstinputlisting[language = Java]{../java/ExceptionDemo7.java}

\subsubsection{实例}
\textbf{毕老师用电脑上课}

开始思考上课中出现的问题。

\textbullet 电脑蓝屏

\textbullet 电脑冒烟

要对问题进行描述，封装成对象。可是当冒烟发生后，会出现讲课进度无法继续。出现了讲师的问题：可是计划无法完成。

\lstinputlisting[language = Java]{../java/ExceptionTest.java}

\textbf{圆形和长方形面积}

有一个长方形和圆形，都可以获取面积，如果出现非法值，视为获取面积时出现的问题。问题通过异常来表示。

注意：先要对这个程序进行基本的设计。

\lstinputlisting[language = Java]{../java/ExceptionTest1.java}
\subsubsection{异常总结}

\textbf{异常：}是对问题的描述。将问题进行对象的封装。

\textbf{异常体系:}

\textit{Throwable}

\qquad |-- \textit{Error}

\qquad |-- \textit{Exception}

\qquad \qquad |-- \textit{RuntimeException}

\textbf{异常体系的特点：}异常体系中的所有类以及建立的对象都具有可抛性。也就是说可以被throw和throws关键字所操作。只有异常体系具备这个特点。

\textbf{throw和throws的特点：}

\textbullet throw定义在函数内，用于抛出异常对象。

\textbullet throws定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开。

当函数内容有throw抛出异常对象，并未进行异常处理。必须要在函数上声明。否则编译失败。

注意：RuntimeException除外。也就是说，函数内如果抛出的是RuntimeException异常，函数上可以不用声明。

\textbf{异常处理}

如果函数声明了异常，调用者需要进行处理。处理方式可抛可try。

异常有两种：

\textbullet 编译时被检测异常。该异常如果在编译时没有处理（没有抛也没有try），编译失败。该异常被标识，代表着可以被处理。

\textbullet 运行时异常（编译时不检测）。在编译时，不需要处理，编译器检查。该异常发生，建议不处理，让程序停止，需要对代码进行修正。

\textbf{异常处理语句}

\textit{try}\{

\qquad 需要检测的代码

\}

\textit{catch}\{

\qquad 处理异常的代码

\}

\textit{finally}\{

一定会执行的代码

\}

有三种结合格式：

\textbullet 第一种

\textit{try}\{

\}

\textit{catch}\{

\}

\textbullet 第二种

\textit{try}\{

\}

\textit{finally}\{

\}

\textbullet 第三种

\textit{try}\{

\}

\textit{catch}\{

\}

\textit{finally}\{

\}

注意：

\textbullet finally中定义的通常是关闭资源代码。因为资源必须要释放。

\textbullet finally只有一种情况不会执行。当执行到System.out.exit(0);finally不会执行。

\textbf{自定义异常}

定义类继承Exception或者RuntimeException

\textbullet 是为了让该自定义类具备可抛性。

\textbullet 让该类具备操作异常的共性方法。

当要定义自定义异常的信息时，可以使用父类已经定义好的功能。将异常信息传递给父类的构造函数。
\begin{lstlisting}[language = Java]
class MyException extends Exception{
	MyException(String message) { 
			super(message);
	}
}
\end{lstlisting}

自定义异常：按照java面向对象思想，将程序中出现的特有问题进行封装。

\textbf{异常的好处}

\textbullet 将问题进行封装。

\textbullet 将正常流程代码和问题处理代码相分离，方便于阅读。

\textbf{异常的处理原则}

\textbullet 处理方式有两种：try或者throws

\textbullet 调用到抛出异常功能时，抛出几个，就处理几个。一个try对应多个catch

\textbullet 多个catch，父类的catch放到最下面。

\textbullet catch内，需要定义针对性的处理方式。不要简单的定义printStackTrace，输出语句也不要写。

当捕获到的异常，本功能处理不了时，可以继续在catch中抛出。

\begin{lstlisting}[language = Java]
try{
	throw new AException();
}
catch(AException) {
	throw e;
}
\end{lstlisting}

如果该异常处理不了，但并不属于该功能出现的异常。可以将异常转换后，再抛出和该功能相关的异常。

或者异常可以处理，但需要将异常产生的和本功能相关的问题提供出去。让调用者知道并处理。也可以将捕获异常处理后，转换新的异常。
\begin{lstlisting}[language = Java]
try{
	//对AException处理
	throw new AException();
}
catch(AException) {
	throw new BException();
}
\end{lstlisting}
比如：汇款的例子

\textbf{异常的注意事项}

在子父类覆盖时：

\textbullet 子类抛出的异常必须是父类异常的子类或者子集。

\textbullet 如果父类或者接口没有抛出异常时，子类覆盖出现异常，只能try不能抛。

\textbf{参阅}

\textbullet ExceptionTest.java 老师用电脑上课。

\textbullet ExceptionTest1.java 图形面积。

\subsection{包}

为了简化类名的书写，使用一个关键字，import。import导入的时包中的类。
建议不要写通配符*，需要用到哪个包的那个类就导入那个类。

建议报名不要重复，可以使用url来完成定义.因为url是唯一的。

类名的全名为 包名.类名

packa包不再当前目录下，需要设置classpath告诉jvm去哪里找指定的packa包。

类公有后，被访问的成员也要公有才可以被访问。

\textbf{总结：}

\textbullet 包与包之间进行访问，被访问的类以及类中的成员，需要public修饰。

\textbullet 不同包中的子类可以直接访问父类中被protected修饰的成员.

\textbullet 包与包之间可以使用的权限只有两种，public和protected。

\begin{tabular}{c|cccc}
%\hline
           &public &protected &default &private \\ \hline
同一个类中 &ok     &ok        &ok      &ok \\
同一个包中 &ok     &ok        &ok      &no \\
子类       &ok     &ok        &no      &no \\
不同包中   &ok     &no        &no      &no \\
\end{tabular}


\lstinputlisting[language = Java]{../java/PackageDemo.java}
\end{document}





